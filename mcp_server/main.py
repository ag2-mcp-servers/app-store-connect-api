# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T15:47:13+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBearer
from fastapi import Query
from pydantic import conint

from models import (
    AgeRatingDeclarationResponse,
    AgeRatingDeclarationUpdateRequest,
    AppBetaTestersLinkagesRequest,
    AppCategoriesResponse,
    AppCategoryResponse,
    AppEncryptionDeclarationBuildsLinkagesRequest,
    AppEncryptionDeclarationResponse,
    AppEncryptionDeclarationsResponse,
    AppInfoLocalizationCreateRequest,
    AppInfoLocalizationResponse,
    AppInfoLocalizationsResponse,
    AppInfoLocalizationUpdateRequest,
    AppInfoResponse,
    AppInfosResponse,
    AppInfoUpdateRequest,
    AppPreOrderCreateRequest,
    AppPreOrderResponse,
    AppPreOrderUpdateRequest,
    AppPreviewCreateRequest,
    AppPreviewResponse,
    AppPreviewSetAppPreviewsLinkagesRequest,
    AppPreviewSetAppPreviewsLinkagesResponse,
    AppPreviewSetCreateRequest,
    AppPreviewSetResponse,
    AppPreviewSetsResponse,
    AppPreviewsResponse,
    AppPreviewUpdateRequest,
    AppPricePointResponse,
    AppPricePointsResponse,
    AppPriceResponse,
    AppPricesResponse,
    AppPriceTierResponse,
    AppPriceTiersResponse,
    AppResponse,
    AppScreenshotCreateRequest,
    AppScreenshotResponse,
    AppScreenshotSetAppScreenshotsLinkagesRequest,
    AppScreenshotSetAppScreenshotsLinkagesResponse,
    AppScreenshotSetCreateRequest,
    AppScreenshotSetResponse,
    AppScreenshotSetsResponse,
    AppScreenshotsResponse,
    AppScreenshotUpdateRequest,
    AppsResponse,
    AppStoreReviewAttachmentCreateRequest,
    AppStoreReviewAttachmentResponse,
    AppStoreReviewAttachmentsResponse,
    AppStoreReviewAttachmentUpdateRequest,
    AppStoreReviewDetailCreateRequest,
    AppStoreReviewDetailResponse,
    AppStoreReviewDetailUpdateRequest,
    AppStoreVersionBuildLinkageRequest,
    AppStoreVersionBuildLinkageResponse,
    AppStoreVersionCreateRequest,
    AppStoreVersionLocalizationCreateRequest,
    AppStoreVersionLocalizationResponse,
    AppStoreVersionLocalizationsResponse,
    AppStoreVersionLocalizationUpdateRequest,
    AppStoreVersionPhasedReleaseCreateRequest,
    AppStoreVersionPhasedReleaseResponse,
    AppStoreVersionPhasedReleaseUpdateRequest,
    AppStoreVersionResponse,
    AppStoreVersionsResponse,
    AppStoreVersionSubmissionCreateRequest,
    AppStoreVersionSubmissionResponse,
    AppStoreVersionUpdateRequest,
    AppUpdateRequest,
    BetaAppLocalizationCreateRequest,
    BetaAppLocalizationResponse,
    BetaAppLocalizationsResponse,
    BetaAppLocalizationUpdateRequest,
    BetaAppReviewDetailResponse,
    BetaAppReviewDetailsResponse,
    BetaAppReviewDetailUpdateRequest,
    BetaAppReviewSubmissionCreateRequest,
    BetaAppReviewSubmissionResponse,
    BetaAppReviewSubmissionsResponse,
    BetaBuildLocalizationCreateRequest,
    BetaBuildLocalizationResponse,
    BetaBuildLocalizationsResponse,
    BetaBuildLocalizationUpdateRequest,
    BetaGroupBetaTestersLinkagesRequest,
    BetaGroupBetaTestersLinkagesResponse,
    BetaGroupBuildsLinkagesRequest,
    BetaGroupBuildsLinkagesResponse,
    BetaGroupCreateRequest,
    BetaGroupResponse,
    BetaGroupsResponse,
    BetaGroupUpdateRequest,
    BetaLicenseAgreementResponse,
    BetaLicenseAgreementsResponse,
    BetaLicenseAgreementUpdateRequest,
    BetaTesterAppsLinkagesRequest,
    BetaTesterAppsLinkagesResponse,
    BetaTesterBetaGroupsLinkagesRequest,
    BetaTesterBetaGroupsLinkagesResponse,
    BetaTesterBuildsLinkagesRequest,
    BetaTesterBuildsLinkagesResponse,
    BetaTesterCreateRequest,
    BetaTesterInvitationCreateRequest,
    BetaTesterInvitationResponse,
    BetaTesterResponse,
    BetaTestersResponse,
    BuildAppEncryptionDeclarationLinkageRequest,
    BuildAppEncryptionDeclarationLinkageResponse,
    BuildBetaDetailResponse,
    BuildBetaDetailsResponse,
    BuildBetaDetailUpdateRequest,
    BuildBetaGroupsLinkagesRequest,
    BuildBetaNotificationCreateRequest,
    BuildBetaNotificationResponse,
    BuildIconsResponse,
    BuildIndividualTestersLinkagesRequest,
    BuildIndividualTestersLinkagesResponse,
    BuildResponse,
    BuildsResponse,
    BuildUpdateRequest,
    BundleIdCapabilitiesResponse,
    BundleIdCapabilityCreateRequest,
    BundleIdCapabilityResponse,
    BundleIdCapabilityUpdateRequest,
    BundleIdCreateRequest,
    BundleIdResponse,
    BundleIdsResponse,
    BundleIdUpdateRequest,
    CertificateCreateRequest,
    CertificateResponse,
    CertificatesResponse,
    DeviceCreateRequest,
    DeviceResponse,
    DevicesResponse,
    DeviceUpdateRequest,
    DiagnosticLogsResponse,
    DiagnosticSignaturesResponse,
    EndUserLicenseAgreementCreateRequest,
    EndUserLicenseAgreementResponse,
    EndUserLicenseAgreementUpdateRequest,
    ErrorResponse,
    ExistsGameCenterEnabledVersions,
    ExistsParent,
    FieldsAgeRatingDeclarations,
    FieldsAgeRatingDeclarations1,
    FieldsAgeRatingDeclarations2,
    FieldsAgeRatingDeclarations3,
    FieldsAgeRatingDeclarations4,
    FieldsAgeRatingDeclarations5,
    FieldsAppCategories,
    FieldsAppCategories1,
    FieldsAppCategories2,
    FieldsAppCategories3,
    FieldsAppCategories4,
    FieldsAppCategories5,
    FieldsAppCategories6,
    FieldsAppCategories7,
    FieldsAppCategories8,
    FieldsAppCategories9,
    FieldsAppCategories10,
    FieldsAppCategories11,
    FieldsAppEncryptionDeclarations,
    FieldsAppEncryptionDeclarations1,
    FieldsAppEncryptionDeclarations2,
    FieldsAppEncryptionDeclarations3,
    FieldsAppEncryptionDeclarations4,
    FieldsAppInfoLocalizations,
    FieldsAppInfoLocalizations1,
    FieldsAppInfoLocalizations2,
    FieldsAppInfoLocalizations3,
    FieldsAppInfos,
    FieldsAppInfos1,
    FieldsAppInfos2,
    FieldsAppInfos3,
    FieldsAppInfos4,
    FieldsAppPreOrders,
    FieldsAppPreOrders1,
    FieldsAppPreOrders2,
    FieldsAppPreOrders3,
    FieldsAppPreviews,
    FieldsAppPreviews1,
    FieldsAppPreviews2,
    FieldsAppPreviews3,
    FieldsAppPreviewSets,
    FieldsAppPreviewSets1,
    FieldsAppPreviewSets2,
    FieldsAppPreviewSets3,
    FieldsAppPricePoints,
    FieldsAppPricePoints1,
    FieldsAppPricePoints2,
    FieldsAppPricePoints3,
    FieldsAppPricePoints4,
    FieldsAppPrices,
    FieldsAppPrices1,
    FieldsAppPrices2,
    FieldsAppPrices3,
    FieldsAppPriceTiers,
    FieldsAppPriceTiers1,
    FieldsAppPriceTiers2,
    FieldsApps,
    FieldsApps1,
    FieldsApps2,
    FieldsApps3,
    FieldsApps4,
    FieldsApps5,
    FieldsApps6,
    FieldsApps7,
    FieldsApps8,
    FieldsApps9,
    FieldsApps10,
    FieldsApps11,
    FieldsApps12,
    FieldsApps13,
    FieldsApps14,
    FieldsApps15,
    FieldsApps16,
    FieldsApps17,
    FieldsApps18,
    FieldsApps19,
    FieldsApps20,
    FieldsApps21,
    FieldsApps22,
    FieldsApps23,
    FieldsApps24,
    FieldsApps25,
    FieldsApps26,
    FieldsApps27,
    FieldsApps28,
    FieldsApps29,
    FieldsApps30,
    FieldsApps31,
    FieldsApps32,
    FieldsApps33,
    FieldsApps34,
    FieldsApps35,
    FieldsApps36,
    FieldsApps37,
    FieldsApps38,
    FieldsApps39,
    FieldsApps40,
    FieldsAppScreenshots,
    FieldsAppScreenshots1,
    FieldsAppScreenshots2,
    FieldsAppScreenshots3,
    FieldsAppScreenshotSets,
    FieldsAppScreenshotSets1,
    FieldsAppScreenshotSets2,
    FieldsAppScreenshotSets3,
    FieldsAppStoreReviewAttachments,
    FieldsAppStoreReviewAttachments1,
    FieldsAppStoreReviewAttachments2,
    FieldsAppStoreReviewAttachments3,
    FieldsAppStoreReviewDetails,
    FieldsAppStoreReviewDetails1,
    FieldsAppStoreReviewDetails2,
    FieldsAppStoreReviewDetails3,
    FieldsAppStoreReviewDetails4,
    FieldsAppStoreVersionLocalizations,
    FieldsAppStoreVersionLocalizations1,
    FieldsAppStoreVersionLocalizations2,
    FieldsAppStoreVersionLocalizations3,
    FieldsAppStoreVersionLocalizations4,
    FieldsAppStoreVersionLocalizations5,
    FieldsAppStoreVersionPhasedReleases,
    FieldsAppStoreVersionPhasedReleases1,
    FieldsAppStoreVersionPhasedReleases2,
    FieldsAppStoreVersions,
    FieldsAppStoreVersions1,
    FieldsAppStoreVersions2,
    FieldsAppStoreVersions3,
    FieldsAppStoreVersions4,
    FieldsAppStoreVersions5,
    FieldsAppStoreVersions6,
    FieldsAppStoreVersions7,
    FieldsAppStoreVersions8,
    FieldsAppStoreVersionSubmissions,
    FieldsAppStoreVersionSubmissions1,
    FieldsAppStoreVersionSubmissions2,
    FieldsBetaAppLocalizations,
    FieldsBetaAppLocalizations1,
    FieldsBetaAppLocalizations2,
    FieldsBetaAppLocalizations3,
    FieldsBetaAppLocalizations4,
    FieldsBetaAppReviewDetails,
    FieldsBetaAppReviewDetails1,
    FieldsBetaAppReviewDetails2,
    FieldsBetaAppReviewDetails3,
    FieldsBetaAppReviewDetails4,
    FieldsBetaAppReviewSubmissions,
    FieldsBetaAppReviewSubmissions1,
    FieldsBetaAppReviewSubmissions2,
    FieldsBetaAppReviewSubmissions3,
    FieldsBetaAppReviewSubmissions4,
    FieldsBetaBuildLocalizations,
    FieldsBetaBuildLocalizations1,
    FieldsBetaBuildLocalizations2,
    FieldsBetaBuildLocalizations3,
    FieldsBetaBuildLocalizations4,
    FieldsBetaGroups,
    FieldsBetaGroups1,
    FieldsBetaGroups2,
    FieldsBetaGroups3,
    FieldsBetaGroups4,
    FieldsBetaGroups5,
    FieldsBetaGroups6,
    FieldsBetaGroups7,
    FieldsBetaLicenseAgreements,
    FieldsBetaLicenseAgreements1,
    FieldsBetaLicenseAgreements2,
    FieldsBetaLicenseAgreements3,
    FieldsBetaLicenseAgreements4,
    FieldsBetaTesters,
    FieldsBetaTesters1,
    FieldsBetaTesters2,
    FieldsBetaTesters3,
    FieldsBetaTesters4,
    FieldsBetaTesters5,
    FieldsBetaTesters6,
    FieldsBetaTesters7,
    FieldsBuildBetaDetails,
    FieldsBuildBetaDetails1,
    FieldsBuildBetaDetails2,
    FieldsBuildBetaDetails3,
    FieldsBuildBetaDetails4,
    FieldsBuildIcons,
    FieldsBuildIcons1,
    FieldsBuildIcons2,
    FieldsBuilds,
    FieldsBuilds1,
    FieldsBuilds2,
    FieldsBuilds3,
    FieldsBuilds4,
    FieldsBuilds5,
    FieldsBuilds6,
    FieldsBuilds7,
    FieldsBuilds8,
    FieldsBuilds9,
    FieldsBuilds10,
    FieldsBuilds11,
    FieldsBuilds12,
    FieldsBuilds13,
    FieldsBuilds14,
    FieldsBuilds15,
    FieldsBuilds16,
    FieldsBuilds17,
    FieldsBuilds18,
    FieldsBuilds19,
    FieldsBuilds20,
    FieldsBuilds21,
    FieldsBuilds22,
    FieldsBuilds23,
    FieldsBuilds24,
    FieldsBuilds25,
    FieldsBundleIdCapabilities,
    FieldsBundleIdCapabilities1,
    FieldsBundleIdCapabilities2,
    FieldsBundleIds,
    FieldsBundleIds1,
    FieldsBundleIds2,
    FieldsBundleIds3,
    FieldsBundleIds4,
    FieldsCertificates,
    FieldsCertificates1,
    FieldsCertificates2,
    FieldsCertificates3,
    FieldsCertificates4,
    FieldsDevices,
    FieldsDevices1,
    FieldsDevices2,
    FieldsDevices3,
    FieldsDevices4,
    FieldsDiagnosticSignatures,
    FieldsDiagnosticSignatures1,
    FieldsDiagnosticSignatures2,
    FieldsEndUserLicenseAgreements,
    FieldsEndUserLicenseAgreements1,
    FieldsEndUserLicenseAgreements2,
    FieldsEndUserLicenseAgreements3,
    FieldsGameCenterEnabledVersions,
    FieldsGameCenterEnabledVersions1,
    FieldsGameCenterEnabledVersions2,
    FieldsGameCenterEnabledVersions3,
    FieldsIdfaDeclarations,
    FieldsIdfaDeclarations1,
    FieldsIdfaDeclarations2,
    FieldsInAppPurchases,
    FieldsInAppPurchases1,
    FieldsInAppPurchases2,
    FieldsInAppPurchases3,
    FieldsPerfPowerMetrics,
    FieldsPerfPowerMetrics1,
    FieldsPerfPowerMetrics2,
    FieldsPerfPowerMetrics3,
    FieldsPreReleaseVersions,
    FieldsPreReleaseVersions1,
    FieldsPreReleaseVersions2,
    FieldsPreReleaseVersions3,
    FieldsPreReleaseVersions4,
    FieldsPreReleaseVersions5,
    FieldsPreReleaseVersions6,
    FieldsPreReleaseVersions7,
    FieldsProfiles,
    FieldsProfiles1,
    FieldsProfiles2,
    FieldsProfiles3,
    FieldsProfiles4,
    FieldsRoutingAppCoverages,
    FieldsRoutingAppCoverages1,
    FieldsRoutingAppCoverages2,
    FieldsRoutingAppCoverages3,
    FieldsTerritories,
    FieldsTerritories1,
    FieldsTerritories2,
    FieldsTerritories3,
    FieldsTerritories4,
    FieldsTerritories5,
    FieldsTerritories6,
    FieldsTerritories7,
    FieldsTerritories8,
    FieldsUserInvitations,
    FieldsUserInvitations1,
    FieldsUsers,
    FieldsUsers1,
    FilterApp,
    FilterApps,
    FilterAppStoreState,
    FilterAppStoreVersion,
    FilterAppStoreVersions,
    FilterAppStoreVersionsAppStoreState,
    FilterAppStoreVersionsPlatform,
    FilterBetaAppReviewSubmissionBetaReviewState,
    FilterBetaGroups,
    FilterBetaReviewState,
    FilterBuild,
    FilterBuilds,
    FilterBuildsExpired,
    FilterBuildsProcessingState,
    FilterBundleId,
    FilterCanBeSubmitted,
    FilterCertificateType,
    FilterDeviceType,
    FilterDiagnosticType,
    FilterDisplayName,
    FilterEmail,
    FilterExpired,
    FilterFirstName,
    FilterFrequency,
    FilterId,
    FilterIdentifier,
    FilterInAppPurchaseType,
    FilterInviteType,
    FilterIsInternalGroup,
    FilterLastName,
    FilterLocale,
    FilterMetricType,
    FilterMetricType1,
    FilterName,
    FilterPlatform2,
    FilterPlatform3,
    FilterPlatform4,
    FilterPlatform5,
    FilterPlatform6,
    FilterPlatform7,
    FilterPlatform8,
    FilterPlatform9,
    FilterPlatform10,
    FilterPlatforms,
    FilterPreReleaseVersion,
    FilterPreReleaseVersionPlatform,
    FilterPreReleaseVersionVersion,
    FilterPreviewType,
    FilterPriceTier,
    FilterProcessingState,
    FilterProfileState,
    FilterProfileType,
    FilterPublicLink,
    FilterPublicLinkEnabled,
    FilterPublicLinkLimitEnabled,
    FilterRegionCode,
    FilterReportDate,
    FilterReportSubType,
    FilterReportType,
    FilterReportType1,
    FilterRoles,
    FilterRoles1,
    FilterScreenshotDisplayType,
    FilterSeedId,
    FilterSerialNumber,
    FilterSku,
    FilterStatus,
    FilterTerritory,
    FilterUdid,
    FilterUsername,
    FilterUsesNonExemptEncryption,
    FilterVendorNumber,
    FilterVersion,
    FilterVersionString,
    FilterVisibleApps,
    GameCenterEnabledVersionCompatibleVersionsLinkagesRequest,
    GameCenterEnabledVersionCompatibleVersionsLinkagesResponse,
    GameCenterEnabledVersionsResponse,
    IdfaDeclarationCreateRequest,
    IdfaDeclarationResponse,
    IdfaDeclarationUpdateRequest,
    InAppPurchaseResponse,
    InAppPurchasesResponse,
    Include,
    Include1,
    Include2,
    Include3,
    Include4,
    Include5,
    Include6,
    Include7,
    Include8,
    Include9,
    Include10,
    Include11,
    Include12,
    Include13,
    Include14,
    Include15,
    Include16,
    Include17,
    Include18,
    Include19,
    Include20,
    Include21,
    Include22,
    Include23,
    Include24,
    Include25,
    Include26,
    Include27,
    Include28,
    Include29,
    Include30,
    Include31,
    Include32,
    Include33,
    Include34,
    Include35,
    Include36,
    Include37,
    Include38,
    Include39,
    Include40,
    Include41,
    Include42,
    Include43,
    Include44,
    Include45,
    Include46,
    Include47,
    Include48,
    Include49,
    Include50,
    Include51,
    Include52,
    Include53,
    Include54,
    Include55,
    Include56,
    Include57,
    Include58,
    Include59,
    Include60,
    Include61,
    Include62,
    Include63,
    Include64,
    Include65,
    Include66,
    PerfPowerMetricsResponse,
    PrereleaseVersionResponse,
    PreReleaseVersionsResponse,
    ProfileCreateRequest,
    ProfileResponse,
    ProfilesResponse,
    RoutingAppCoverageCreateRequest,
    RoutingAppCoverageResponse,
    RoutingAppCoverageUpdateRequest,
    Sort,
    Sort1,
    Sort2,
    Sort3,
    Sort4,
    Sort5,
    Sort6,
    Sort7,
    Sort8,
    Sort9,
    Sort10,
    Sort11,
    Sort12,
    Sort13,
    TerritoriesResponse,
    TerritoryResponse,
    UserInvitationCreateRequest,
    UserInvitationResponse,
    UserInvitationsResponse,
    UserResponse,
    UsersResponse,
    UserUpdateRequest,
    UserVisibleAppsLinkagesRequest,
    UserVisibleAppsLinkagesResponse,
)

app = MCPProxy(
    title='App Store Connect API',
    version='1.4.1',
    servers=[{'url': 'https://api.appstoreconnect.apple.com/'}],
)


@app.patch(
    '/v1/ageRatingDeclarations/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def age_rating_declarations_update_instance(
    id: str, body: AgeRatingDeclarationUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appCategories',
    tags=['app_info_management', 'app_listing_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_categories_get_collection(
    filter_platforms_: Optional[FilterPlatforms] = Query(
        None, alias='filter[platforms]'
    ),
    exists_parent_: Optional[ExistsParent] = Query(None, alias='exists[parent]'),
    fields_app_categories_: Optional[FieldsAppCategories] = Query(
        None, alias='fields[appCategories]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include] = None,
    limit_subcategories_: Optional[conint(le=50)] = Query(
        None, alias='limit[subcategories]'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appCategories/{id}',
    tags=[
        'app_category_management',
        'app_info_management',
        'app_information_retrieval',
        'app_listing_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_categories_get_instance(
    fields_app_categories_: Optional[FieldsAppCategories1] = Query(
        None, alias='fields[appCategories]'
    ),
    include: Optional[Include1] = None,
    limit_subcategories_: Optional[conint(le=50)] = Query(
        None, alias='limit[subcategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appCategories/{id}/parent',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_categories_parent_get_to_one_related(
    fields_app_categories_: Optional[FieldsAppCategories2] = Query(
        None, alias='fields[appCategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appCategories/{id}/subcategories',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_categories_subcategories_get_to_many_related(
    fields_app_categories_: Optional[FieldsAppCategories3] = Query(
        None, alias='fields[appCategories]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appEncryptionDeclarations',
    tags=[
        'app_information_retrieval',
        'app_listing_management',
        'app_builds_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_encryption_declarations_get_collection(
    filter_platform_: Optional[FilterPlatform2] = Query(None, alias='filter[platform]'),
    filter_app_: Optional[FilterApp] = Query(None, alias='filter[app]'),
    filter_builds_: Optional[FilterBuilds] = Query(None, alias='filter[builds]'),
    fields_app_encryption_declarations_: Optional[
        FieldsAppEncryptionDeclarations
    ] = Query(None, alias='fields[appEncryptionDeclarations]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include2] = None,
    fields_apps_: Optional[FieldsApps] = Query(None, alias='fields[apps]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appEncryptionDeclarations/{id}',
    tags=['app_encryption_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_encryption_declarations_get_instance(
    fields_app_encryption_declarations_: Optional[
        FieldsAppEncryptionDeclarations1
    ] = Query(None, alias='fields[appEncryptionDeclarations]'),
    include: Optional[Include3] = None,
    fields_apps_: Optional[FieldsApps1] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appEncryptionDeclarations/{id}/app',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_encryption_declarations_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps2] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appEncryptionDeclarations/{id}/relationships/builds',
    tags=['app_encryption_management', 'build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_encryption_declarations_builds_create_to_many_relationship(
    id: str, body: AppEncryptionDeclarationBuildsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appInfoLocalizations',
    tags=[
        'app_info_localization_management',
        'app_info_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_info_localizations_create_instance(body: AppInfoLocalizationCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appInfoLocalizations/{id}',
    tags=['user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_info_localizations_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfoLocalizations/{id}',
    tags=['app_info_localization_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_info_localizations_get_instance(
    fields_app_info_localizations_: Optional[FieldsAppInfoLocalizations] = Query(
        None, alias='fields[appInfoLocalizations]'
    ),
    include: Optional[Include4] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appInfoLocalizations/{id}',
    tags=[
        'app_info_localization_management',
        'app_info_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_info_localizations_update_instance(
    id: str, body: AppInfoLocalizationUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}',
    tags=[
        'app_info_management',
        'app_info_localization_management',
        'app_information_retrieval',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_get_instance(
    fields_app_infos_: Optional[FieldsAppInfos] = Query(None, alias='fields[appInfos]'),
    include: Optional[Include5] = None,
    fields_age_rating_declarations_: Optional[FieldsAgeRatingDeclarations] = Query(
        None, alias='fields[ageRatingDeclarations]'
    ),
    fields_app_categories_: Optional[FieldsAppCategories4] = Query(
        None, alias='fields[appCategories]'
    ),
    fields_app_info_localizations_: Optional[FieldsAppInfoLocalizations1] = Query(
        None, alias='fields[appInfoLocalizations]'
    ),
    limit_app_info_localizations_: Optional[conint(le=50)] = Query(
        None, alias='limit[appInfoLocalizations]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appInfos/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_update_instance(id: str, body: AppInfoUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/ageRatingDeclaration',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_age_rating_declaration_get_to_one_related(
    fields_age_rating_declarations_: Optional[FieldsAgeRatingDeclarations1] = Query(
        None, alias='fields[ageRatingDeclarations]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/appInfoLocalizations',
    tags=[
        'app_info_localization_management',
        'app_info_management',
        'app_information_retrieval',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_app_info_localizations_get_to_many_related(
    filter_locale_: Optional[FilterLocale] = Query(None, alias='filter[locale]'),
    fields_app_infos_: Optional[FieldsAppInfos1] = Query(
        None, alias='fields[appInfos]'
    ),
    fields_app_info_localizations_: Optional[FieldsAppInfoLocalizations2] = Query(
        None, alias='fields[appInfoLocalizations]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include6] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/primaryCategory',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_primary_category_get_to_one_related(
    fields_app_categories_: Optional[FieldsAppCategories5] = Query(
        None, alias='fields[appCategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/primarySubcategoryOne',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_primary_subcategory_one_get_to_one_related(
    fields_app_categories_: Optional[FieldsAppCategories6] = Query(
        None, alias='fields[appCategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/primarySubcategoryTwo',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_primary_subcategory_two_get_to_one_related(
    fields_app_categories_: Optional[FieldsAppCategories7] = Query(
        None, alias='fields[appCategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/secondaryCategory',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_secondary_category_get_to_one_related(
    fields_app_categories_: Optional[FieldsAppCategories8] = Query(
        None, alias='fields[appCategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/secondarySubcategoryOne',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_secondary_subcategory_one_get_to_one_related(
    fields_app_categories_: Optional[FieldsAppCategories9] = Query(
        None, alias='fields[appCategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appInfos/{id}/secondarySubcategoryTwo',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_infos_secondary_subcategory_two_get_to_one_related(
    fields_app_categories_: Optional[FieldsAppCategories10] = Query(
        None, alias='fields[appCategories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appPreOrders',
    tags=['app_pre_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_pre_orders_create_instance(body: AppPreOrderCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appPreOrders/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_pre_orders_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPreOrders/{id}',
    tags=['app_pre_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_pre_orders_get_instance(
    fields_app_pre_orders_: Optional[FieldsAppPreOrders] = Query(
        None, alias='fields[appPreOrders]'
    ),
    include: Optional[Include7] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appPreOrders/{id}',
    tags=['app_pre_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_pre_orders_update_instance(id: str, body: AppPreOrderUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appPreviewSets',
    tags=['app_preview_set_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_preview_sets_create_instance(body: AppPreviewSetCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appPreviewSets/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_preview_sets_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPreviewSets/{id}',
    tags=['app_preview_set_management', 'app_previews_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_preview_sets_get_instance(
    fields_app_preview_sets_: Optional[FieldsAppPreviewSets] = Query(
        None, alias='fields[appPreviewSets]'
    ),
    include: Optional[Include8] = None,
    fields_app_previews_: Optional[FieldsAppPreviews] = Query(
        None, alias='fields[appPreviews]'
    ),
    limit_app_previews_: Optional[conint(le=50)] = Query(
        None, alias='limit[appPreviews]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPreviewSets/{id}/appPreviews',
    tags=[
        'app_previews_management',
        'app_preview_set_management',
        'app_info_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_preview_sets_app_previews_get_to_many_related(
    fields_app_previews_: Optional[FieldsAppPreviews1] = Query(
        None, alias='fields[appPreviews]'
    ),
    fields_app_preview_sets_: Optional[FieldsAppPreviewSets1] = Query(
        None, alias='fields[appPreviewSets]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include9] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPreviewSets/{id}/relationships/appPreviews',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_preview_sets_app_previews_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appPreviewSets/{id}/relationships/appPreviews',
    tags=['app_preview_set_management', 'app_previews_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_preview_sets_app_previews_replace_to_many_relationship(
    id: str, body: AppPreviewSetAppPreviewsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appPreviews',
    tags=['app_preview_set_management', 'app_previews_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_previews_create_instance(body: AppPreviewCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appPreviews/{id}',
    tags=['app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_previews_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPreviews/{id}',
    tags=['app_previews_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_previews_get_instance(
    fields_app_previews_: Optional[FieldsAppPreviews2] = Query(
        None, alias='fields[appPreviews]'
    ),
    include: Optional[Include10] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appPreviews/{id}',
    tags=['app_previews_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_previews_update_instance(id: str, body: AppPreviewUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPricePoints',
    tags=[
        'app_price_management',
        'app_listing_management',
        'app_information_retrieval',
        'territory_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_price_points_get_collection(
    filter_price_tier_: Optional[FilterPriceTier] = Query(
        None, alias='filter[priceTier]'
    ),
    filter_territory_: Optional[FilterTerritory] = Query(
        None, alias='filter[territory]'
    ),
    fields_app_price_points_: Optional[FieldsAppPricePoints] = Query(
        None, alias='fields[appPricePoints]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include11] = None,
    fields_territories_: Optional[FieldsTerritories] = Query(
        None, alias='fields[territories]'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPricePoints/{id}',
    tags=['app_price_management', 'app_information_retrieval', 'territory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_price_points_get_instance(
    fields_app_price_points_: Optional[FieldsAppPricePoints1] = Query(
        None, alias='fields[appPricePoints]'
    ),
    include: Optional[Include12] = None,
    fields_territories_: Optional[FieldsTerritories1] = Query(
        None, alias='fields[territories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPricePoints/{id}/territory',
    tags=['territory_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_price_points_territory_get_to_one_related(
    fields_territories_: Optional[FieldsTerritories2] = Query(
        None, alias='fields[territories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPriceTiers',
    tags=['app_price_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_price_tiers_get_collection(
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    fields_app_price_tiers_: Optional[FieldsAppPriceTiers] = Query(
        None, alias='fields[appPriceTiers]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include13] = None,
    fields_app_price_points_: Optional[FieldsAppPricePoints2] = Query(
        None, alias='fields[appPricePoints]'
    ),
    limit_price_points_: Optional[conint(le=50)] = Query(
        None, alias='limit[pricePoints]'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPriceTiers/{id}',
    tags=['app_price_management', 'app_store_interaction_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_price_tiers_get_instance(
    fields_app_price_tiers_: Optional[FieldsAppPriceTiers1] = Query(
        None, alias='fields[appPriceTiers]'
    ),
    include: Optional[Include14] = None,
    fields_app_price_points_: Optional[FieldsAppPricePoints3] = Query(
        None, alias='fields[appPricePoints]'
    ),
    limit_price_points_: Optional[conint(le=50)] = Query(
        None, alias='limit[pricePoints]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPriceTiers/{id}/pricePoints',
    tags=['app_price_management', 'app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_price_tiers_price_points_get_to_many_related(
    fields_app_price_points_: Optional[FieldsAppPricePoints4] = Query(
        None, alias='fields[appPricePoints]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appPrices/{id}',
    tags=['app_price_management', 'app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_prices_get_instance(
    fields_app_prices_: Optional[FieldsAppPrices] = Query(
        None, alias='fields[appPrices]'
    ),
    include: Optional[Include15] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appScreenshotSets',
    tags=['app_screenshot_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshot_sets_create_instance(body: AppScreenshotSetCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appScreenshotSets/{id}',
    tags=['app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshot_sets_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appScreenshotSets/{id}',
    tags=['app_screenshot_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshot_sets_get_instance(
    fields_app_screenshot_sets_: Optional[FieldsAppScreenshotSets] = Query(
        None, alias='fields[appScreenshotSets]'
    ),
    include: Optional[Include16] = None,
    fields_app_screenshots_: Optional[FieldsAppScreenshots] = Query(
        None, alias='fields[appScreenshots]'
    ),
    limit_app_screenshots_: Optional[conint(le=50)] = Query(
        None, alias='limit[appScreenshots]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appScreenshotSets/{id}/appScreenshots',
    tags=['app_screenshot_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshot_sets_app_screenshots_get_to_many_related(
    fields_app_screenshot_sets_: Optional[FieldsAppScreenshotSets1] = Query(
        None, alias='fields[appScreenshotSets]'
    ),
    fields_app_screenshots_: Optional[FieldsAppScreenshots1] = Query(
        None, alias='fields[appScreenshots]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include17] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appScreenshotSets/{id}/relationships/appScreenshots',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshot_sets_app_screenshots_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appScreenshotSets/{id}/relationships/appScreenshots',
    tags=['app_screenshot_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshot_sets_app_screenshots_replace_to_many_relationship(
    id: str, body: AppScreenshotSetAppScreenshotsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appScreenshots',
    tags=['app_screenshot_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshots_create_instance(body: AppScreenshotCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appScreenshots/{id}',
    tags=['app_info_management', 'app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshots_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appScreenshots/{id}',
    tags=['app_screenshot_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshots_get_instance(
    fields_app_screenshots_: Optional[FieldsAppScreenshots2] = Query(
        None, alias='fields[appScreenshots]'
    ),
    include: Optional[Include18] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appScreenshots/{id}',
    tags=['app_screenshot_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_screenshots_update_instance(id: str, body: AppScreenshotUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appStoreReviewAttachments',
    tags=['app_store_review_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_review_attachments_create_instance(
    body: AppStoreReviewAttachmentCreateRequest,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appStoreReviewAttachments/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_review_attachments_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreReviewAttachments/{id}',
    tags=['app_store_review_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_review_attachments_get_instance(
    fields_app_store_review_attachments_: Optional[
        FieldsAppStoreReviewAttachments
    ] = Query(None, alias='fields[appStoreReviewAttachments]'),
    include: Optional[Include19] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appStoreReviewAttachments/{id}',
    tags=['app_store_review_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_review_attachments_update_instance(
    id: str, body: AppStoreReviewAttachmentUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appStoreReviewDetails',
    tags=['app_store_review_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_review_details_create_instance(body: AppStoreReviewDetailCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreReviewDetails/{id}',
    tags=['app_store_review_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_review_details_get_instance(
    fields_app_store_review_details_: Optional[FieldsAppStoreReviewDetails] = Query(
        None, alias='fields[appStoreReviewDetails]'
    ),
    include: Optional[Include20] = None,
    fields_app_store_review_attachments_: Optional[
        FieldsAppStoreReviewAttachments1
    ] = Query(None, alias='fields[appStoreReviewAttachments]'),
    limit_app_store_review_attachments_: Optional[conint(le=50)] = Query(
        None, alias='limit[appStoreReviewAttachments]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appStoreReviewDetails/{id}',
    tags=['app_store_review_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_review_details_update_instance(
    id: str, body: AppStoreReviewDetailUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreReviewDetails/{id}/appStoreReviewAttachments',
    tags=['app_store_review_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_app_store_review_details_and_attachments(
    fields_app_store_review_details_: Optional[FieldsAppStoreReviewDetails1] = Query(
        None, alias='fields[appStoreReviewDetails]'
    ),
    fields_app_store_review_attachments_: Optional[
        FieldsAppStoreReviewAttachments2
    ] = Query(None, alias='fields[appStoreReviewAttachments]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include21] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appStoreVersionLocalizations',
    tags=[
        'app_store_version_localization_management',
        'app_info_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_localizations_create_instance(
    body: AppStoreVersionLocalizationCreateRequest,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appStoreVersionLocalizations/{id}',
    tags=['app_info_management', 'app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_localizations_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersionLocalizations/{id}',
    tags=[
        'app_info_localization_management',
        'app_preview_set_management',
        'app_screenshot_management',
        'app_store_version_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_localizations_get_instance(
    fields_app_store_version_localizations_: Optional[
        FieldsAppStoreVersionLocalizations
    ] = Query(None, alias='fields[appStoreVersionLocalizations]'),
    include: Optional[Include22] = None,
    fields_app_screenshot_sets_: Optional[FieldsAppScreenshotSets2] = Query(
        None, alias='fields[appScreenshotSets]'
    ),
    fields_app_preview_sets_: Optional[FieldsAppPreviewSets2] = Query(
        None, alias='fields[appPreviewSets]'
    ),
    limit_app_preview_sets_: Optional[conint(le=50)] = Query(
        None, alias='limit[appPreviewSets]'
    ),
    limit_app_screenshot_sets_: Optional[conint(le=50)] = Query(
        None, alias='limit[appScreenshotSets]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appStoreVersionLocalizations/{id}',
    tags=[
        'app_store_version_localization_management',
        'app_info_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_localizations_update_instance(
    id: str, body: AppStoreVersionLocalizationUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersionLocalizations/{id}/appPreviewSets',
    tags=[
        'app_preview_set_management',
        'app_previews_management',
        'app_store_version_localization_management',
        'app_info_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_app_store_version_localizations_preview_sets(
    filter_preview_type_: Optional[FilterPreviewType] = Query(
        None, alias='filter[previewType]'
    ),
    fields_app_store_version_localizations_: Optional[
        FieldsAppStoreVersionLocalizations1
    ] = Query(None, alias='fields[appStoreVersionLocalizations]'),
    fields_app_previews_: Optional[FieldsAppPreviews3] = Query(
        None, alias='fields[appPreviews]'
    ),
    fields_app_preview_sets_: Optional[FieldsAppPreviewSets3] = Query(
        None, alias='fields[appPreviewSets]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include23] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersionLocalizations/{id}/appScreenshotSets',
    tags=['app_screenshot_management', 'app_store_version_localization_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_app_screenshot_sets_with_localizations(
    filter_screenshot_display_type_: Optional[FilterScreenshotDisplayType] = Query(
        None, alias='filter[screenshotDisplayType]'
    ),
    fields_app_store_version_localizations_: Optional[
        FieldsAppStoreVersionLocalizations2
    ] = Query(None, alias='fields[appStoreVersionLocalizations]'),
    fields_app_screenshot_sets_: Optional[FieldsAppScreenshotSets3] = Query(
        None, alias='fields[appScreenshotSets]'
    ),
    fields_app_screenshots_: Optional[FieldsAppScreenshots3] = Query(
        None, alias='fields[appScreenshots]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include24] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appStoreVersionPhasedReleases',
    tags=['app_store_version_phased_release_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_phased_releases_create_instance(
    body: AppStoreVersionPhasedReleaseCreateRequest,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appStoreVersionPhasedReleases/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_phased_releases_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appStoreVersionPhasedReleases/{id}',
    tags=['app_store_version_phased_release_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_phased_releases_update_instance(
    id: str, body: AppStoreVersionPhasedReleaseUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appStoreVersionSubmissions',
    tags=['app_store_version_submission_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_submissions_create_instance(
    body: AppStoreVersionSubmissionCreateRequest,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appStoreVersionSubmissions/{id}',
    tags=['app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_version_submissions_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/appStoreVersions',
    tags=['app_store_version_management', 'app_store_version_submission_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_create_instance(body: AppStoreVersionCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/appStoreVersions/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}',
    tags=[
        'app_info_management',
        'app_store_version_submission_management',
        'app_store_version_management',
        'app_store_version_localization_management',
        'app_store_version_phased_release_management',
        'app_store_review_management',
        'idfa_declaration_management',
        'routing_app_coverage_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_get_instance(
    fields_app_store_versions_: Optional[FieldsAppStoreVersions] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    include: Optional[Include25] = None,
    fields_app_store_version_localizations_: Optional[
        FieldsAppStoreVersionLocalizations3
    ] = Query(None, alias='fields[appStoreVersionLocalizations]'),
    fields_idfa_declarations_: Optional[FieldsIdfaDeclarations] = Query(
        None, alias='fields[idfaDeclarations]'
    ),
    fields_routing_app_coverages_: Optional[FieldsRoutingAppCoverages] = Query(
        None, alias='fields[routingAppCoverages]'
    ),
    fields_app_store_version_phased_releases_: Optional[
        FieldsAppStoreVersionPhasedReleases
    ] = Query(None, alias='fields[appStoreVersionPhasedReleases]'),
    fields_age_rating_declarations_: Optional[FieldsAgeRatingDeclarations2] = Query(
        None, alias='fields[ageRatingDeclarations]'
    ),
    fields_app_store_review_details_: Optional[FieldsAppStoreReviewDetails2] = Query(
        None, alias='fields[appStoreReviewDetails]'
    ),
    fields_builds_: Optional[FieldsBuilds] = Query(None, alias='fields[builds]'),
    fields_app_store_version_submissions_: Optional[
        FieldsAppStoreVersionSubmissions
    ] = Query(None, alias='fields[appStoreVersionSubmissions]'),
    limit_app_store_version_localizations_: Optional[conint(le=50)] = Query(
        None, alias='limit[appStoreVersionLocalizations]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appStoreVersions/{id}',
    tags=[
        'app_store_version_management',
        'app_store_version_submission_management',
        'app_store_version_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_update_instance(
    id: str, body: AppStoreVersionUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/ageRatingDeclaration',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_age_rating_declaration_get_to_one_related(
    fields_age_rating_declarations_: Optional[FieldsAgeRatingDeclarations3] = Query(
        None, alias='fields[ageRatingDeclarations]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/appStoreReviewDetail',
    tags=[
        'app_store_review_management',
        'app_store_version_management',
        'app_information_retrieval',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_app_store_review_detail_get_to_one_related(
    fields_app_store_review_details_: Optional[FieldsAppStoreReviewDetails3] = Query(
        None, alias='fields[appStoreReviewDetails]'
    ),
    fields_app_store_versions_: Optional[FieldsAppStoreVersions1] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    fields_app_store_review_attachments_: Optional[
        FieldsAppStoreReviewAttachments3
    ] = Query(None, alias='fields[appStoreReviewAttachments]'),
    include: Optional[Include26] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/appStoreVersionLocalizations',
    tags=[
        'app_store_version_localization_management',
        'app_info_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_app_store_version_localizations(
    fields_app_store_version_localizations_: Optional[
        FieldsAppStoreVersionLocalizations4
    ] = Query(None, alias='fields[appStoreVersionLocalizations]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/appStoreVersionPhasedRelease',
    tags=[
        'app_store_version_phased_release_management',
        'app_store_version_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_app_store_version_phased_release_by_id(
    fields_app_store_version_phased_releases_: Optional[
        FieldsAppStoreVersionPhasedReleases1
    ] = Query(None, alias='fields[appStoreVersionPhasedReleases]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/appStoreVersionSubmission',
    tags=[
        'app_store_version_submission_management',
        'app_store_version_management',
        'app_information_retrieval',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_app_store_version_submission_details(
    fields_app_store_versions_: Optional[FieldsAppStoreVersions2] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    fields_app_store_version_submissions_: Optional[
        FieldsAppStoreVersionSubmissions1
    ] = Query(None, alias='fields[appStoreVersionSubmissions]'),
    include: Optional[Include27] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/build',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'build_related_entities_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_build_get_to_one_related(
    fields_builds_: Optional[FieldsBuilds1] = Query(None, alias='fields[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/idfaDeclaration',
    tags=['idfa_declaration_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_idfa_declaration_get_to_one_related(
    fields_idfa_declarations_: Optional[FieldsIdfaDeclarations1] = Query(
        None, alias='fields[idfaDeclarations]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/relationships/build',
    tags=['app_information_retrieval', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_build_get_to_one_relationship(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/appStoreVersions/{id}/relationships/build',
    tags=['build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_build_update_to_one_relationship(
    id: str, body: AppStoreVersionBuildLinkageRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/appStoreVersions/{id}/routingAppCoverage',
    tags=['routing_app_coverage_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def app_store_versions_routing_app_coverage_get_to_one_related(
    fields_routing_app_coverages_: Optional[FieldsRoutingAppCoverages1] = Query(
        None, alias='fields[routingAppCoverages]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps',
    tags=[
        'app_store_version_management',
        'app_information_retrieval',
        'app_store_version_submission_management',
        'app_store_interaction_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_get_collection(
    filter_app_store_versions_app_store_state_: Optional[
        FilterAppStoreVersionsAppStoreState
    ] = Query(None, alias='filter[appStoreVersions.appStoreState]'),
    filter_app_store_versions_platform_: Optional[
        FilterAppStoreVersionsPlatform
    ] = Query(None, alias='filter[appStoreVersions.platform]'),
    filter_bundle_id_: Optional[FilterBundleId] = Query(None, alias='filter[bundleId]'),
    filter_name_: Optional[FilterName] = Query(None, alias='filter[name]'),
    filter_sku_: Optional[FilterSku] = Query(None, alias='filter[sku]'),
    filter_app_store_versions_: Optional[FilterAppStoreVersions] = Query(
        None, alias='filter[appStoreVersions]'
    ),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    exists_game_center_enabled_versions_: Optional[
        ExistsGameCenterEnabledVersions
    ] = Query(None, alias='exists[gameCenterEnabledVersions]'),
    sort: Optional[Sort] = None,
    fields_apps_: Optional[FieldsApps3] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include28] = None,
    fields_beta_groups_: Optional[FieldsBetaGroups] = Query(
        None, alias='fields[betaGroups]'
    ),
    fields_perf_power_metrics_: Optional[FieldsPerfPowerMetrics] = Query(
        None, alias='fields[perfPowerMetrics]'
    ),
    fields_app_infos_: Optional[FieldsAppInfos2] = Query(
        None, alias='fields[appInfos]'
    ),
    fields_app_pre_orders_: Optional[FieldsAppPreOrders1] = Query(
        None, alias='fields[appPreOrders]'
    ),
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    fields_app_prices_: Optional[FieldsAppPrices1] = Query(
        None, alias='fields[appPrices]'
    ),
    fields_in_app_purchases_: Optional[FieldsInAppPurchases] = Query(
        None, alias='fields[inAppPurchases]'
    ),
    fields_beta_app_review_details_: Optional[FieldsBetaAppReviewDetails] = Query(
        None, alias='fields[betaAppReviewDetails]'
    ),
    fields_territories_: Optional[FieldsTerritories3] = Query(
        None, alias='fields[territories]'
    ),
    fields_game_center_enabled_versions_: Optional[
        FieldsGameCenterEnabledVersions
    ] = Query(None, alias='fields[gameCenterEnabledVersions]'),
    fields_app_store_versions_: Optional[FieldsAppStoreVersions3] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    fields_builds_: Optional[FieldsBuilds2] = Query(None, alias='fields[builds]'),
    fields_beta_app_localizations_: Optional[FieldsBetaAppLocalizations] = Query(
        None, alias='fields[betaAppLocalizations]'
    ),
    fields_beta_license_agreements_: Optional[FieldsBetaLicenseAgreements] = Query(
        None, alias='fields[betaLicenseAgreements]'
    ),
    fields_end_user_license_agreements_: Optional[
        FieldsEndUserLicenseAgreements
    ] = Query(None, alias='fields[endUserLicenseAgreements]'),
    limit_app_infos_: Optional[conint(le=50)] = Query(None, alias='limit[appInfos]'),
    limit_app_store_versions_: Optional[conint(le=50)] = Query(
        None, alias='limit[appStoreVersions]'
    ),
    limit_available_territories_: Optional[conint(le=50)] = Query(
        None, alias='limit[availableTerritories]'
    ),
    limit_beta_app_localizations_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaAppLocalizations]'
    ),
    limit_beta_groups_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaGroups]'
    ),
    limit_builds_: Optional[conint(le=50)] = Query(None, alias='limit[builds]'),
    limit_game_center_enabled_versions_: Optional[conint(le=50)] = Query(
        None, alias='limit[gameCenterEnabledVersions]'
    ),
    limit_in_app_purchases_: Optional[conint(le=50)] = Query(
        None, alias='limit[inAppPurchases]'
    ),
    limit_pre_release_versions_: Optional[conint(le=50)] = Query(
        None, alias='limit[preReleaseVersions]'
    ),
    limit_prices_: Optional[conint(le=50)] = Query(None, alias='limit[prices]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}',
    tags=[
        'app_info_management',
        'beta_app_management',
        'beta_group_management',
        'in_app_purchase_management',
        'pre_release_version_management',
        'territory_management',
        'user_license_agreement_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_get_instance(
    fields_apps_: Optional[FieldsApps4] = Query(None, alias='fields[apps]'),
    include: Optional[Include29] = None,
    fields_beta_groups_: Optional[FieldsBetaGroups1] = Query(
        None, alias='fields[betaGroups]'
    ),
    fields_perf_power_metrics_: Optional[FieldsPerfPowerMetrics1] = Query(
        None, alias='fields[perfPowerMetrics]'
    ),
    fields_app_infos_: Optional[FieldsAppInfos3] = Query(
        None, alias='fields[appInfos]'
    ),
    fields_app_pre_orders_: Optional[FieldsAppPreOrders2] = Query(
        None, alias='fields[appPreOrders]'
    ),
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions1] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    fields_app_prices_: Optional[FieldsAppPrices2] = Query(
        None, alias='fields[appPrices]'
    ),
    fields_in_app_purchases_: Optional[FieldsInAppPurchases1] = Query(
        None, alias='fields[inAppPurchases]'
    ),
    fields_beta_app_review_details_: Optional[FieldsBetaAppReviewDetails1] = Query(
        None, alias='fields[betaAppReviewDetails]'
    ),
    fields_territories_: Optional[FieldsTerritories4] = Query(
        None, alias='fields[territories]'
    ),
    fields_game_center_enabled_versions_: Optional[
        FieldsGameCenterEnabledVersions1
    ] = Query(None, alias='fields[gameCenterEnabledVersions]'),
    fields_app_store_versions_: Optional[FieldsAppStoreVersions4] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    fields_builds_: Optional[FieldsBuilds3] = Query(None, alias='fields[builds]'),
    fields_beta_app_localizations_: Optional[FieldsBetaAppLocalizations1] = Query(
        None, alias='fields[betaAppLocalizations]'
    ),
    fields_beta_license_agreements_: Optional[FieldsBetaLicenseAgreements1] = Query(
        None, alias='fields[betaLicenseAgreements]'
    ),
    fields_end_user_license_agreements_: Optional[
        FieldsEndUserLicenseAgreements1
    ] = Query(None, alias='fields[endUserLicenseAgreements]'),
    limit_app_infos_: Optional[conint(le=50)] = Query(None, alias='limit[appInfos]'),
    limit_app_store_versions_: Optional[conint(le=50)] = Query(
        None, alias='limit[appStoreVersions]'
    ),
    limit_available_territories_: Optional[conint(le=50)] = Query(
        None, alias='limit[availableTerritories]'
    ),
    limit_beta_app_localizations_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaAppLocalizations]'
    ),
    limit_beta_groups_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaGroups]'
    ),
    limit_builds_: Optional[conint(le=50)] = Query(None, alias='limit[builds]'),
    limit_game_center_enabled_versions_: Optional[conint(le=50)] = Query(
        None, alias='limit[gameCenterEnabledVersions]'
    ),
    limit_in_app_purchases_: Optional[conint(le=50)] = Query(
        None, alias='limit[inAppPurchases]'
    ),
    limit_pre_release_versions_: Optional[conint(le=50)] = Query(
        None, alias='limit[preReleaseVersions]'
    ),
    limit_prices_: Optional[conint(le=50)] = Query(None, alias='limit[prices]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/apps/{id}',
    tags=['app_information_retrieval', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_update_instance(id: str, body: AppUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/appInfos',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_app_infos_get_to_many_related(
    fields_age_rating_declarations_: Optional[FieldsAgeRatingDeclarations4] = Query(
        None, alias='fields[ageRatingDeclarations]'
    ),
    fields_app_infos_: Optional[FieldsAppInfos4] = Query(
        None, alias='fields[appInfos]'
    ),
    fields_app_categories_: Optional[FieldsAppCategories11] = Query(
        None, alias='fields[appCategories]'
    ),
    fields_app_info_localizations_: Optional[FieldsAppInfoLocalizations3] = Query(
        None, alias='fields[appInfoLocalizations]'
    ),
    fields_apps_: Optional[FieldsApps5] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include30] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/appStoreVersions',
    tags=[
        'app_info_management',
        'app_information_retrieval',
        'app_store_version_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_app_store_versions_get_to_many_related(
    filter_app_store_state_: Optional[FilterAppStoreState] = Query(
        None, alias='filter[appStoreState]'
    ),
    filter_platform_: Optional[FilterPlatform3] = Query(None, alias='filter[platform]'),
    filter_version_string_: Optional[FilterVersionString] = Query(
        None, alias='filter[versionString]'
    ),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    fields_idfa_declarations_: Optional[FieldsIdfaDeclarations2] = Query(
        None, alias='fields[idfaDeclarations]'
    ),
    fields_app_store_version_localizations_: Optional[
        FieldsAppStoreVersionLocalizations5
    ] = Query(None, alias='fields[appStoreVersionLocalizations]'),
    fields_routing_app_coverages_: Optional[FieldsRoutingAppCoverages2] = Query(
        None, alias='fields[routingAppCoverages]'
    ),
    fields_app_store_version_phased_releases_: Optional[
        FieldsAppStoreVersionPhasedReleases2
    ] = Query(None, alias='fields[appStoreVersionPhasedReleases]'),
    fields_age_rating_declarations_: Optional[FieldsAgeRatingDeclarations5] = Query(
        None, alias='fields[ageRatingDeclarations]'
    ),
    fields_app_store_review_details_: Optional[FieldsAppStoreReviewDetails4] = Query(
        None, alias='fields[appStoreReviewDetails]'
    ),
    fields_app_store_versions_: Optional[FieldsAppStoreVersions5] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    fields_builds_: Optional[FieldsBuilds4] = Query(None, alias='fields[builds]'),
    fields_app_store_version_submissions_: Optional[
        FieldsAppStoreVersionSubmissions2
    ] = Query(None, alias='fields[appStoreVersionSubmissions]'),
    fields_apps_: Optional[FieldsApps6] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include31] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/availableTerritories',
    tags=['territory_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_available_territories_get_to_many_related(
    fields_territories_: Optional[FieldsTerritories5] = Query(
        None, alias='fields[territories]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/betaAppLocalizations',
    tags=[
        'beta_localization_management',
        'localization_management',
        'beta_app_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_beta_app_localizations_get_to_many_related(
    fields_beta_app_localizations_: Optional[FieldsBetaAppLocalizations2] = Query(
        None, alias='fields[betaAppLocalizations]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/betaAppReviewDetail',
    tags=[
        'beta_app_management',
        'beta_review_management',
        'localization_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_beta_app_review_detail_get_to_one_related(
    fields_beta_app_review_details_: Optional[FieldsBetaAppReviewDetails2] = Query(
        None, alias='fields[betaAppReviewDetails]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/betaGroups',
    tags=['beta_group_management', 'beta_app_management', 'localization_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_beta_groups_get_to_many_related(
    fields_beta_groups_: Optional[FieldsBetaGroups2] = Query(
        None, alias='fields[betaGroups]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/betaLicenseAgreement',
    tags=['beta_license_agreement_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_beta_license_agreement_get_to_one_related(
    fields_beta_license_agreements_: Optional[FieldsBetaLicenseAgreements2] = Query(
        None, alias='fields[betaLicenseAgreements]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/builds',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'build_related_entities_management',
        'build_performance_metrics_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_builds_get_to_many_related(
    fields_builds_: Optional[FieldsBuilds5] = Query(None, alias='fields[builds]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/endUserLicenseAgreement',
    tags=[
        'user_license_agreement_management',
        'end_user_license_management',
        'license_agreement_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_end_user_license_agreement_get_to_one_related(
    fields_end_user_license_agreements_: Optional[
        FieldsEndUserLicenseAgreements2
    ] = Query(None, alias='fields[endUserLicenseAgreements]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/gameCenterEnabledVersions',
    tags=['app_listing_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_game_center_enabled_versions_get_to_many_related(
    filter_platform_: Optional[FilterPlatform4] = Query(None, alias='filter[platform]'),
    filter_version_string_: Optional[FilterVersionString] = Query(
        None, alias='filter[versionString]'
    ),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort1] = None,
    fields_game_center_enabled_versions_: Optional[
        FieldsGameCenterEnabledVersions2
    ] = Query(None, alias='fields[gameCenterEnabledVersions]'),
    fields_apps_: Optional[FieldsApps7] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include32] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/inAppPurchases',
    tags=[
        'in_app_purchase_management',
        'app_store_interaction_management',
        'app_listing_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_in_app_purchases_get_to_many_related(
    filter_in_app_purchase_type_: Optional[FilterInAppPurchaseType] = Query(
        None, alias='filter[inAppPurchaseType]'
    ),
    filter_can_be_submitted_: Optional[FilterCanBeSubmitted] = Query(
        None, alias='filter[canBeSubmitted]'
    ),
    sort: Optional[Sort2] = None,
    fields_in_app_purchases_: Optional[FieldsInAppPurchases2] = Query(
        None, alias='fields[inAppPurchases]'
    ),
    fields_apps_: Optional[FieldsApps8] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include33] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/perfPowerMetrics',
    tags=[
        'app_information_retrieval',
        'app_listing_management',
        'app_metrics_analysis',
        'device_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_perf_power_metrics_get_to_many_related(
    filter_device_type_: Optional[FilterDeviceType] = Query(
        None, alias='filter[deviceType]'
    ),
    filter_metric_type_: Optional[FilterMetricType] = Query(
        None, alias='filter[metricType]'
    ),
    filter_platform_: Optional[FilterPlatform5] = Query(None, alias='filter[platform]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/preOrder',
    tags=['app_pre_order_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_pre_order_get_to_one_related(
    fields_app_pre_orders_: Optional[FieldsAppPreOrders3] = Query(
        None, alias='fields[appPreOrders]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/preReleaseVersions',
    tags=['pre_release_version_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_pre_release_versions_get_to_many_related(
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions2] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{id}/prices',
    tags=[
        'app_price_management',
        'app_info_management',
        'app_listing_management',
        'app_information_retrieval',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_prices_get_to_many_related(
    fields_app_prices_: Optional[FieldsAppPrices3] = Query(
        None, alias='fields[appPrices]'
    ),
    fields_app_price_tiers_: Optional[FieldsAppPriceTiers2] = Query(
        None, alias='fields[appPriceTiers]'
    ),
    fields_apps_: Optional[FieldsApps9] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include34] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{id}/relationships/betaTesters',
    tags=['beta_tester_management', 'beta_group_management', 'beta_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def apps_beta_testers_delete_to_many_relationship(
    id: str, body: AppBetaTestersLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppLocalizations',
    tags=[
        'app_info_localization_management',
        'beta_app_management',
        'localization_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_localizations_get_collection(
    filter_locale_: Optional[FilterLocale] = Query(None, alias='filter[locale]'),
    filter_app_: Optional[FilterApp] = Query(None, alias='filter[app]'),
    fields_beta_app_localizations_: Optional[FieldsBetaAppLocalizations3] = Query(
        None, alias='fields[betaAppLocalizations]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include35] = None,
    fields_apps_: Optional[FieldsApps10] = Query(None, alias='fields[apps]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaAppLocalizations',
    tags=[
        'beta_app_management',
        'beta_localization_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_localizations_create_instance(body: BetaAppLocalizationCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaAppLocalizations/{id}',
    tags=['app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_localizations_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppLocalizations/{id}',
    tags=[
        'beta_app_management',
        'app_info_localization_management',
        'localization_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_localizations_get_instance(
    fields_beta_app_localizations_: Optional[FieldsBetaAppLocalizations4] = Query(
        None, alias='fields[betaAppLocalizations]'
    ),
    include: Optional[Include36] = None,
    fields_apps_: Optional[FieldsApps11] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/betaAppLocalizations/{id}',
    tags=[
        'app_info_localization_management',
        'beta_localization_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_localizations_update_instance(
    id: str, body: BetaAppLocalizationUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppLocalizations/{id}/app',
    tags=['app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_localizations_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps12] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppReviewDetails',
    tags=[
        'beta_app_management',
        'app_info_management',
        'app_information_retrieval',
        'localization_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_details_get_collection(
    filter_app_: FilterApp = Query(..., alias='filter[app]'),
    fields_beta_app_review_details_: Optional[FieldsBetaAppReviewDetails3] = Query(
        None, alias='fields[betaAppReviewDetails]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include37] = None,
    fields_apps_: Optional[FieldsApps13] = Query(None, alias='fields[apps]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppReviewDetails/{id}',
    tags=[
        'beta_app_management',
        'beta_review_management',
        'localization_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_details_get_instance(
    fields_beta_app_review_details_: Optional[FieldsBetaAppReviewDetails4] = Query(
        None, alias='fields[betaAppReviewDetails]'
    ),
    include: Optional[Include38] = None,
    fields_apps_: Optional[FieldsApps14] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/betaAppReviewDetails/{id}',
    tags=[
        'beta_app_management',
        'beta_review_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_details_update_instance(
    id: str, body: BetaAppReviewDetailUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppReviewDetails/{id}/app',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_details_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps15] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppReviewSubmissions',
    tags=[
        'beta_app_management',
        'beta_review_management',
        'build_detail_management',
        'build_related_entities_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_submissions_get_collection(
    filter_beta_review_state_: Optional[FilterBetaReviewState] = Query(
        None, alias='filter[betaReviewState]'
    ),
    filter_build_: FilterBuild = Query(..., alias='filter[build]'),
    fields_beta_app_review_submissions_: Optional[
        FieldsBetaAppReviewSubmissions
    ] = Query(None, alias='fields[betaAppReviewSubmissions]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include39] = None,
    fields_builds_: Optional[FieldsBuilds6] = Query(None, alias='fields[builds]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaAppReviewSubmissions',
    tags=['beta_review_management', 'beta_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_submissions_create_instance(
    body: BetaAppReviewSubmissionCreateRequest,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppReviewSubmissions/{id}',
    tags=[
        'beta_app_management',
        'beta_review_management',
        'beta_localization_management',
        'build_detail_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_submissions_get_instance(
    fields_beta_app_review_submissions_: Optional[
        FieldsBetaAppReviewSubmissions1
    ] = Query(None, alias='fields[betaAppReviewSubmissions]'),
    include: Optional[Include40] = None,
    fields_builds_: Optional[FieldsBuilds7] = Query(None, alias='fields[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaAppReviewSubmissions/{id}/build',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'build_related_entities_management',
        'build_performance_metrics_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_app_review_submissions_build_get_to_one_related(
    fields_builds_: Optional[FieldsBuilds8] = Query(None, alias='fields[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaBuildLocalizations',
    tags=[
        'beta_localization_management',
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_build_localizations_get_collection(
    filter_locale_: Optional[FilterLocale] = Query(None, alias='filter[locale]'),
    filter_build_: Optional[FilterBuild] = Query(None, alias='filter[build]'),
    fields_beta_build_localizations_: Optional[FieldsBetaBuildLocalizations] = Query(
        None, alias='fields[betaBuildLocalizations]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include41] = None,
    fields_builds_: Optional[FieldsBuilds9] = Query(None, alias='fields[builds]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaBuildLocalizations',
    tags=['beta_localization_management', 'app_info_localization_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_build_localizations_create_instance(body: BetaBuildLocalizationCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaBuildLocalizations/{id}',
    tags=['app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_build_localizations_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaBuildLocalizations/{id}',
    tags=[
        'beta_localization_management',
        'beta_app_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_build_localizations_get_instance(
    fields_beta_build_localizations_: Optional[FieldsBetaBuildLocalizations1] = Query(
        None, alias='fields[betaBuildLocalizations]'
    ),
    include: Optional[Include42] = None,
    fields_builds_: Optional[FieldsBuilds10] = Query(None, alias='fields[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/betaBuildLocalizations/{id}',
    tags=[
        'app_info_localization_management',
        'beta_localization_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_build_localizations_update_instance(
    id: str, body: BetaBuildLocalizationUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaBuildLocalizations/{id}/build',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'build_related_entities_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_build_localizations_build_get_to_one_related(
    fields_builds_: Optional[FieldsBuilds11] = Query(None, alias='fields[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaGroups',
    tags=[
        'beta_group_management',
        'beta_tester_management',
        'build_relationships_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_get_collection(
    filter_is_internal_group_: Optional[FilterIsInternalGroup] = Query(
        None, alias='filter[isInternalGroup]'
    ),
    filter_name_: Optional[FilterName] = Query(None, alias='filter[name]'),
    filter_public_link_: Optional[FilterPublicLink] = Query(
        None, alias='filter[publicLink]'
    ),
    filter_public_link_enabled_: Optional[FilterPublicLinkEnabled] = Query(
        None, alias='filter[publicLinkEnabled]'
    ),
    filter_public_link_limit_enabled_: Optional[FilterPublicLinkLimitEnabled] = Query(
        None, alias='filter[publicLinkLimitEnabled]'
    ),
    filter_app_: Optional[FilterApp] = Query(None, alias='filter[app]'),
    filter_builds_: Optional[FilterBuilds] = Query(None, alias='filter[builds]'),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort3] = None,
    fields_beta_groups_: Optional[FieldsBetaGroups3] = Query(
        None, alias='fields[betaGroups]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include43] = None,
    fields_builds_: Optional[FieldsBuilds12] = Query(None, alias='fields[builds]'),
    fields_beta_testers_: Optional[FieldsBetaTesters] = Query(
        None, alias='fields[betaTesters]'
    ),
    fields_apps_: Optional[FieldsApps16] = Query(None, alias='fields[apps]'),
    limit_beta_testers_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaTesters]'
    ),
    limit_builds_: Optional[conint(le=1000)] = Query(None, alias='limit[builds]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaGroups',
    tags=['beta_group_management', 'beta_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_create_instance(body: BetaGroupCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaGroups/{id}',
    tags=['app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaGroups/{id}',
    tags=[
        'beta_app_management',
        'beta_group_management',
        'beta_tester_management',
        'build_relationships_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_get_instance(
    fields_beta_groups_: Optional[FieldsBetaGroups4] = Query(
        None, alias='fields[betaGroups]'
    ),
    include: Optional[Include44] = None,
    fields_builds_: Optional[FieldsBuilds13] = Query(None, alias='fields[builds]'),
    fields_beta_testers_: Optional[FieldsBetaTesters1] = Query(
        None, alias='fields[betaTesters]'
    ),
    fields_apps_: Optional[FieldsApps17] = Query(None, alias='fields[apps]'),
    limit_beta_testers_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaTesters]'
    ),
    limit_builds_: Optional[conint(le=1000)] = Query(None, alias='limit[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/betaGroups/{id}',
    tags=['beta_group_management', 'beta_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_update_instance(id: str, body: BetaGroupUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaGroups/{id}/app',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps18] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaGroups/{id}/betaTesters',
    tags=[
        'beta_tester_management',
        'beta_group_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_beta_testers_get_to_many_related(
    fields_beta_testers_: Optional[FieldsBetaTesters2] = Query(
        None, alias='fields[betaTesters]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaGroups/{id}/builds',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_builds_get_to_many_related(
    fields_builds_: Optional[FieldsBuilds14] = Query(None, alias='fields[builds]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaGroups/{id}/relationships/betaTesters',
    tags=['beta_group_management', 'beta_tester_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_beta_testers_delete_to_many_relationship(
    id: str, body: BetaGroupBetaTestersLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaGroups/{id}/relationships/betaTesters',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_beta_testers_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaGroups/{id}/relationships/betaTesters',
    tags=['beta_group_management', 'beta_tester_management', 'beta_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_beta_testers_create_to_many_relationship(
    id: str, body: BetaGroupBetaTestersLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaGroups/{id}/relationships/builds',
    tags=['beta_group_management', 'build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_builds_delete_to_many_relationship(
    id: str, body: BetaGroupBuildsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaGroups/{id}/relationships/builds',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_builds_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaGroups/{id}/relationships/builds',
    tags=[
        'beta_group_management',
        'build_relationships_management',
        'beta_app_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_groups_builds_create_to_many_relationship(
    id: str, body: BetaGroupBuildsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaLicenseAgreements',
    tags=['beta_license_agreement_management', 'user_license_agreement_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_license_agreements_get_collection(
    filter_app_: Optional[FilterApp] = Query(None, alias='filter[app]'),
    fields_beta_license_agreements_: Optional[FieldsBetaLicenseAgreements3] = Query(
        None, alias='fields[betaLicenseAgreements]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include45] = None,
    fields_apps_: Optional[FieldsApps19] = Query(None, alias='fields[apps]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaLicenseAgreements/{id}',
    tags=[
        'beta_license_agreement_management',
        'beta_app_management',
        'user_license_agreement_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_license_agreements_get_instance(
    fields_beta_license_agreements_: Optional[FieldsBetaLicenseAgreements4] = Query(
        None, alias='fields[betaLicenseAgreements]'
    ),
    include: Optional[Include46] = None,
    fields_apps_: Optional[FieldsApps20] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/betaLicenseAgreements/{id}',
    tags=['beta_license_agreement_management', 'user_license_agreement_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_license_agreements_update_instance(
    id: str, body: BetaLicenseAgreementUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaLicenseAgreements/{id}/app',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_license_agreements_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps21] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaTesterInvitations',
    tags=[
        'beta_tester_management',
        'beta_app_management',
        'beta_localization_management',
        'beta_group_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_tester_invitations_create_instance(body: BetaTesterInvitationCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters',
    tags=[
        'beta_group_management',
        'beta_tester_management',
        'user_invitation_management',
        'user_invitations_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_get_collection(
    filter_email_: Optional[FilterEmail] = Query(None, alias='filter[email]'),
    filter_first_name_: Optional[FilterFirstName] = Query(
        None, alias='filter[firstName]'
    ),
    filter_invite_type_: Optional[FilterInviteType] = Query(
        None, alias='filter[inviteType]'
    ),
    filter_last_name_: Optional[FilterLastName] = Query(None, alias='filter[lastName]'),
    filter_apps_: Optional[FilterApps] = Query(None, alias='filter[apps]'),
    filter_beta_groups_: Optional[FilterBetaGroups] = Query(
        None, alias='filter[betaGroups]'
    ),
    filter_builds_: Optional[FilterBuilds] = Query(None, alias='filter[builds]'),
    sort: Optional[Sort4] = None,
    fields_beta_testers_: Optional[FieldsBetaTesters3] = Query(
        None, alias='fields[betaTesters]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include47] = None,
    fields_beta_groups_: Optional[FieldsBetaGroups5] = Query(
        None, alias='fields[betaGroups]'
    ),
    fields_builds_: Optional[FieldsBuilds15] = Query(None, alias='fields[builds]'),
    fields_apps_: Optional[FieldsApps22] = Query(None, alias='fields[apps]'),
    limit_apps_: Optional[conint(le=50)] = Query(None, alias='limit[apps]'),
    limit_beta_groups_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaGroups]'
    ),
    limit_builds_: Optional[conint(le=50)] = Query(None, alias='limit[builds]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaTesters',
    tags=[
        'beta_tester_management',
        'beta_group_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_create_instance(body: BetaTesterCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaTesters/{id}',
    tags=['app_information_retrieval', 'app_info_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters/{id}',
    tags=[
        'beta_app_management',
        'beta_group_management',
        'beta_tester_management',
        'build_relationships_management',
        'build_detail_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_get_instance(
    fields_beta_testers_: Optional[FieldsBetaTesters4] = Query(
        None, alias='fields[betaTesters]'
    ),
    include: Optional[Include48] = None,
    fields_beta_groups_: Optional[FieldsBetaGroups6] = Query(
        None, alias='fields[betaGroups]'
    ),
    fields_builds_: Optional[FieldsBuilds16] = Query(None, alias='fields[builds]'),
    fields_apps_: Optional[FieldsApps23] = Query(None, alias='fields[apps]'),
    limit_apps_: Optional[conint(le=50)] = Query(None, alias='limit[apps]'),
    limit_beta_groups_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaGroups]'
    ),
    limit_builds_: Optional[conint(le=50)] = Query(None, alias='limit[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters/{id}/apps',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_apps_get_to_many_related(
    fields_apps_: Optional[FieldsApps24] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters/{id}/betaGroups',
    tags=[
        'beta_group_management',
        'beta_app_management',
        'localization_management',
        'beta_localization_management',
        'beta_tester_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_beta_groups_get_to_many_related(
    fields_beta_groups_: Optional[FieldsBetaGroups7] = Query(
        None, alias='fields[betaGroups]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters/{id}/builds',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_builds_get_to_many_related(
    fields_builds_: Optional[FieldsBuilds17] = Query(None, alias='fields[builds]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaTesters/{id}/relationships/apps',
    tags=[
        'beta_app_management',
        'beta_tester_management',
        'beta_localization_management',
        'beta_group_management',
        'beta_review_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_apps_delete_to_many_relationship(
    id: str, body: BetaTesterAppsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters/{id}/relationships/apps',
    tags=['app_info_management', 'app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_apps_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaTesters/{id}/relationships/betaGroups',
    tags=['beta_group_management', 'beta_tester_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_beta_groups_delete_to_many_relationship(
    id: str, body: BetaTesterBetaGroupsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters/{id}/relationships/betaGroups',
    tags=['app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_beta_groups_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaTesters/{id}/relationships/betaGroups',
    tags=['beta_group_management', 'beta_tester_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_beta_groups_create_to_many_relationship(
    id: str, body: BetaTesterBetaGroupsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/betaTesters/{id}/relationships/builds',
    tags=[
        'beta_tester_management',
        'build_relationships_management',
        'build_detail_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_builds_delete_to_many_relationship(
    id: str, body: BetaTesterBuildsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/betaTesters/{id}/relationships/builds',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_builds_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/betaTesters/{id}/relationships/builds',
    tags=[
        'beta_localization_management',
        'beta_tester_management',
        'build_relationships_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def beta_testers_builds_create_to_many_relationship(
    id: str, body: BetaTesterBuildsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/buildBetaDetails',
    tags=[
        'build_detail_management',
        'build_collection_management',
        'build_relationships_management',
        'build_performance_metrics_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def build_beta_details_get_collection(
    filter_build_: Optional[FilterBuild] = Query(None, alias='filter[build]'),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    fields_build_beta_details_: Optional[FieldsBuildBetaDetails] = Query(
        None, alias='fields[buildBetaDetails]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include49] = None,
    fields_builds_: Optional[FieldsBuilds18] = Query(None, alias='fields[builds]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/buildBetaDetails/{id}',
    tags=[
        'build_detail_management',
        'beta_app_management',
        'beta_group_management',
        'build_relationships_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def build_beta_details_get_instance(
    fields_build_beta_details_: Optional[FieldsBuildBetaDetails1] = Query(
        None, alias='fields[buildBetaDetails]'
    ),
    include: Optional[Include50] = None,
    fields_builds_: Optional[FieldsBuilds19] = Query(None, alias='fields[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/buildBetaDetails/{id}',
    tags=['beta_app_management', 'build_detail_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def build_beta_details_update_instance(
    id: str, body: BuildBetaDetailUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/buildBetaDetails/{id}/build',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def build_beta_details_build_get_to_one_related(
    fields_builds_: Optional[FieldsBuilds20] = Query(None, alias='fields[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/buildBetaNotifications',
    tags=[
        'beta_app_management',
        'beta_localization_management',
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'build_performance_metrics_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def build_beta_notifications_create_instance(body: BuildBetaNotificationCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds',
    tags=[
        'beta_app_management',
        'beta_review_management',
        'beta_localization_management',
        'beta_group_management',
        'beta_tester_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_get_collection(
    filter_beta_app_review_submission_beta_review_state_: Optional[
        FilterBetaAppReviewSubmissionBetaReviewState
    ] = Query(None, alias='filter[betaAppReviewSubmission.betaReviewState]'),
    filter_expired_: Optional[FilterExpired] = Query(None, alias='filter[expired]'),
    filter_pre_release_version_platform_: Optional[
        FilterPreReleaseVersionPlatform
    ] = Query(None, alias='filter[preReleaseVersion.platform]'),
    filter_pre_release_version_version_: Optional[
        FilterPreReleaseVersionVersion
    ] = Query(None, alias='filter[preReleaseVersion.version]'),
    filter_processing_state_: Optional[FilterProcessingState] = Query(
        None, alias='filter[processingState]'
    ),
    filter_uses_non_exempt_encryption_: Optional[FilterUsesNonExemptEncryption] = Query(
        None, alias='filter[usesNonExemptEncryption]'
    ),
    filter_version_: Optional[FilterVersion] = Query(None, alias='filter[version]'),
    filter_app_: Optional[FilterApp] = Query(None, alias='filter[app]'),
    filter_app_store_version_: Optional[FilterAppStoreVersion] = Query(
        None, alias='filter[appStoreVersion]'
    ),
    filter_beta_groups_: Optional[FilterBetaGroups] = Query(
        None, alias='filter[betaGroups]'
    ),
    filter_pre_release_version_: Optional[FilterPreReleaseVersion] = Query(
        None, alias='filter[preReleaseVersion]'
    ),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort5] = None,
    fields_builds_: Optional[FieldsBuilds21] = Query(None, alias='fields[builds]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include51] = None,
    fields_app_encryption_declarations_: Optional[
        FieldsAppEncryptionDeclarations2
    ] = Query(None, alias='fields[appEncryptionDeclarations]'),
    fields_beta_app_review_submissions_: Optional[
        FieldsBetaAppReviewSubmissions2
    ] = Query(None, alias='fields[betaAppReviewSubmissions]'),
    fields_build_beta_details_: Optional[FieldsBuildBetaDetails2] = Query(
        None, alias='fields[buildBetaDetails]'
    ),
    fields_build_icons_: Optional[FieldsBuildIcons] = Query(
        None, alias='fields[buildIcons]'
    ),
    fields_perf_power_metrics_: Optional[FieldsPerfPowerMetrics2] = Query(
        None, alias='fields[perfPowerMetrics]'
    ),
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions3] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    fields_app_store_versions_: Optional[FieldsAppStoreVersions6] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    fields_diagnostic_signatures_: Optional[FieldsDiagnosticSignatures] = Query(
        None, alias='fields[diagnosticSignatures]'
    ),
    fields_beta_testers_: Optional[FieldsBetaTesters5] = Query(
        None, alias='fields[betaTesters]'
    ),
    fields_beta_build_localizations_: Optional[FieldsBetaBuildLocalizations2] = Query(
        None, alias='fields[betaBuildLocalizations]'
    ),
    fields_apps_: Optional[FieldsApps25] = Query(None, alias='fields[apps]'),
    limit_beta_build_localizations_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaBuildLocalizations]'
    ),
    limit_icons_: Optional[conint(le=50)] = Query(None, alias='limit[icons]'),
    limit_individual_testers_: Optional[conint(le=50)] = Query(
        None, alias='limit[individualTesters]'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}',
    tags=[
        'beta_app_management',
        'beta_review_management',
        'beta_tester_management',
        'build_detail_management',
        'build_related_entities_management',
        'build_performance_metrics_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_get_instance(
    fields_builds_: Optional[FieldsBuilds22] = Query(None, alias='fields[builds]'),
    include: Optional[Include52] = None,
    fields_app_encryption_declarations_: Optional[
        FieldsAppEncryptionDeclarations3
    ] = Query(None, alias='fields[appEncryptionDeclarations]'),
    fields_beta_app_review_submissions_: Optional[
        FieldsBetaAppReviewSubmissions3
    ] = Query(None, alias='fields[betaAppReviewSubmissions]'),
    fields_build_beta_details_: Optional[FieldsBuildBetaDetails3] = Query(
        None, alias='fields[buildBetaDetails]'
    ),
    fields_build_icons_: Optional[FieldsBuildIcons1] = Query(
        None, alias='fields[buildIcons]'
    ),
    fields_perf_power_metrics_: Optional[FieldsPerfPowerMetrics3] = Query(
        None, alias='fields[perfPowerMetrics]'
    ),
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions4] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    fields_app_store_versions_: Optional[FieldsAppStoreVersions7] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    fields_diagnostic_signatures_: Optional[FieldsDiagnosticSignatures1] = Query(
        None, alias='fields[diagnosticSignatures]'
    ),
    fields_beta_testers_: Optional[FieldsBetaTesters6] = Query(
        None, alias='fields[betaTesters]'
    ),
    fields_beta_build_localizations_: Optional[FieldsBetaBuildLocalizations3] = Query(
        None, alias='fields[betaBuildLocalizations]'
    ),
    fields_apps_: Optional[FieldsApps26] = Query(None, alias='fields[apps]'),
    limit_beta_build_localizations_: Optional[conint(le=50)] = Query(
        None, alias='limit[betaBuildLocalizations]'
    ),
    limit_icons_: Optional[conint(le=50)] = Query(None, alias='limit[icons]'),
    limit_individual_testers_: Optional[conint(le=50)] = Query(
        None, alias='limit[individualTesters]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/builds/{id}',
    tags=['build_relationships_management', 'build_detail_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_update_instance(id: str, body: BuildUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/app',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps27] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/appEncryptionDeclaration',
    tags=['app_encryption_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_app_encryption_declaration_get_to_one_related(
    fields_app_encryption_declarations_: Optional[
        FieldsAppEncryptionDeclarations4
    ] = Query(None, alias='fields[appEncryptionDeclarations]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/appStoreVersion',
    tags=['app_store_version_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_app_store_version_get_to_one_related(
    fields_app_store_versions_: Optional[FieldsAppStoreVersions8] = Query(
        None, alias='fields[appStoreVersions]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/betaAppReviewSubmission',
    tags=[
        'beta_review_management',
        'beta_app_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_beta_app_review_submission_get_to_one_related(
    fields_beta_app_review_submissions_: Optional[
        FieldsBetaAppReviewSubmissions4
    ] = Query(None, alias='fields[betaAppReviewSubmissions]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/betaBuildLocalizations',
    tags=[
        'beta_localization_management',
        'app_info_localization_management',
        'localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_beta_build_localizations_get_to_many_related(
    fields_beta_build_localizations_: Optional[FieldsBetaBuildLocalizations4] = Query(
        None, alias='fields[betaBuildLocalizations]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/buildBetaDetail',
    tags=[
        'beta_app_management',
        'build_detail_management',
        'build_relationships_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_build_beta_detail_get_to_one_related(
    fields_build_beta_details_: Optional[FieldsBuildBetaDetails4] = Query(
        None, alias='fields[buildBetaDetails]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/diagnosticSignatures',
    tags=['app_information_retrieval', 'app_listing_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_diagnostic_signatures_get_to_many_related(
    filter_diagnostic_type_: Optional[FilterDiagnosticType] = Query(
        None, alias='filter[diagnosticType]'
    ),
    fields_diagnostic_signatures_: Optional[FieldsDiagnosticSignatures2] = Query(
        None, alias='fields[diagnosticSignatures]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/icons',
    tags=['build_related_entities_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_icons_get_to_many_related(
    fields_build_icons_: Optional[FieldsBuildIcons2] = Query(
        None, alias='fields[buildIcons]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/individualTesters',
    tags=[
        'beta_tester_management',
        'beta_group_management',
        'beta_localization_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_individual_testers_get_to_many_related(
    fields_beta_testers_: Optional[FieldsBetaTesters7] = Query(
        None, alias='fields[betaTesters]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/perfPowerMetrics',
    tags=['app_information_retrieval', 'app_listing_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_perf_power_metrics_get_to_many_related(
    filter_device_type_: Optional[FilterDeviceType] = Query(
        None, alias='filter[deviceType]'
    ),
    filter_metric_type_: Optional[FilterMetricType1] = Query(
        None, alias='filter[metricType]'
    ),
    filter_platform_: Optional[FilterPlatform6] = Query(None, alias='filter[platform]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/preReleaseVersion',
    tags=['pre_release_version_management', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_pre_release_version_get_to_one_related(
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions5] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/relationships/appEncryptionDeclaration',
    tags=['app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_app_encryption_declaration_get_to_one_relationship(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/builds/{id}/relationships/appEncryptionDeclaration',
    tags=['app_encryption_management', 'build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_app_encryption_declaration_update_to_one_relationship(
    id: str, body: BuildAppEncryptionDeclarationLinkageRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/builds/{id}/relationships/betaGroups',
    tags=['beta_group_management', 'build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_beta_groups_delete_to_many_relationship(
    id: str, body: BuildBetaGroupsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/builds/{id}/relationships/betaGroups',
    tags=['beta_group_management', 'build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_beta_groups_create_to_many_relationship(
    id: str, body: BuildBetaGroupsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/builds/{id}/relationships/individualTesters',
    tags=['individual_tester_management', 'build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_individual_testers_delete_to_many_relationship(
    id: str, body: BuildIndividualTestersLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/builds/{id}/relationships/individualTesters',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_individual_testers_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/builds/{id}/relationships/individualTesters',
    tags=['individual_tester_management', 'build_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def builds_individual_testers_create_to_many_relationship(
    id: str, body: BuildIndividualTestersLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/bundleIdCapabilities',
    tags=['bundle_id_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_id_capabilities_create_instance(body: BundleIdCapabilityCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/bundleIdCapabilities/{id}',
    tags=['app_info_management', 'app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_id_capabilities_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/bundleIdCapabilities/{id}',
    tags=['bundle_id_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_id_capabilities_update_instance(
    id: str, body: BundleIdCapabilityUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/bundleIds',
    tags=['app_listing_management', 'app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_get_collection(
    filter_identifier_: Optional[FilterIdentifier] = Query(
        None, alias='filter[identifier]'
    ),
    filter_name_: Optional[FilterName] = Query(None, alias='filter[name]'),
    filter_platform_: Optional[FilterPlatform7] = Query(None, alias='filter[platform]'),
    filter_seed_id_: Optional[FilterSeedId] = Query(None, alias='filter[seedId]'),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort6] = None,
    fields_bundle_ids_: Optional[FieldsBundleIds] = Query(
        None, alias='fields[bundleIds]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include53] = None,
    fields_bundle_id_capabilities_: Optional[FieldsBundleIdCapabilities] = Query(
        None, alias='fields[bundleIdCapabilities]'
    ),
    fields_profiles_: Optional[FieldsProfiles] = Query(None, alias='fields[profiles]'),
    fields_apps_: Optional[FieldsApps28] = Query(None, alias='fields[apps]'),
    limit_bundle_id_capabilities_: Optional[conint(le=50)] = Query(
        None, alias='limit[bundleIdCapabilities]'
    ),
    limit_profiles_: Optional[conint(le=50)] = Query(None, alias='limit[profiles]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/bundleIds',
    tags=['bundle_id_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_create_instance(body: BundleIdCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/bundleIds/{id}',
    tags=['app_information_retrieval', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/bundleIds/{id}',
    tags=['bundle_id_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_get_instance(
    fields_bundle_ids_: Optional[FieldsBundleIds1] = Query(
        None, alias='fields[bundleIds]'
    ),
    include: Optional[Include54] = None,
    fields_bundle_id_capabilities_: Optional[FieldsBundleIdCapabilities1] = Query(
        None, alias='fields[bundleIdCapabilities]'
    ),
    fields_profiles_: Optional[FieldsProfiles1] = Query(None, alias='fields[profiles]'),
    fields_apps_: Optional[FieldsApps29] = Query(None, alias='fields[apps]'),
    limit_bundle_id_capabilities_: Optional[conint(le=50)] = Query(
        None, alias='limit[bundleIdCapabilities]'
    ),
    limit_profiles_: Optional[conint(le=50)] = Query(None, alias='limit[profiles]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/bundleIds/{id}',
    tags=['bundle_id_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_update_instance(id: str, body: BundleIdUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/bundleIds/{id}/app',
    tags=['app_info_management', 'app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps30] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/bundleIds/{id}/bundleIdCapabilities',
    tags=[
        'app_info_management',
        'app_info_localization_management',
        'bundle_id_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_bundle_id_capabilities_get_to_many_related(
    fields_bundle_id_capabilities_: Optional[FieldsBundleIdCapabilities2] = Query(
        None, alias='fields[bundleIdCapabilities]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/bundleIds/{id}/profiles',
    tags=[
        'app_information_retrieval',
        'app_info_management',
        'user_profile_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def bundle_ids_profiles_get_to_many_related(
    fields_profiles_: Optional[FieldsProfiles2] = Query(None, alias='fields[profiles]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/certificates',
    tags=['certificate_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def certificates_get_collection(
    filter_certificate_type_: Optional[FilterCertificateType] = Query(
        None, alias='filter[certificateType]'
    ),
    filter_display_name_: Optional[FilterDisplayName] = Query(
        None, alias='filter[displayName]'
    ),
    filter_serial_number_: Optional[FilterSerialNumber] = Query(
        None, alias='filter[serialNumber]'
    ),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort7] = None,
    fields_certificates_: Optional[FieldsCertificates] = Query(
        None, alias='fields[certificates]'
    ),
    limit: Optional[conint(le=200)] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/certificates',
    tags=['certificate_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def certificates_create_instance(body: CertificateCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/certificates/{id}',
    tags=['app_info_management', 'app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def certificates_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/certificates/{id}',
    tags=['certificate_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def certificates_get_instance(
    fields_certificates_: Optional[FieldsCertificates1] = Query(
        None, alias='fields[certificates]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/devices',
    tags=['app_listing_management', 'app_information_retrieval', 'device_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def devices_get_collection(
    filter_name_: Optional[FilterName] = Query(None, alias='filter[name]'),
    filter_platform_: Optional[FilterPlatform8] = Query(None, alias='filter[platform]'),
    filter_status_: Optional[FilterStatus] = Query(None, alias='filter[status]'),
    filter_udid_: Optional[FilterUdid] = Query(None, alias='filter[udid]'),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort8] = None,
    fields_devices_: Optional[FieldsDevices] = Query(None, alias='fields[devices]'),
    limit: Optional[conint(le=200)] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/devices',
    tags=['device_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def devices_create_instance(body: DeviceCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/devices/{id}',
    tags=['device_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def devices_get_instance(
    fields_devices_: Optional[FieldsDevices1] = Query(None, alias='fields[devices]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/devices/{id}',
    tags=['device_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def devices_update_instance(id: str, body: DeviceUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/diagnosticSignatures/{id}/logs',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def diagnostic_signatures_logs_get_to_many_related(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/endUserLicenseAgreements',
    tags=[
        'user_license_agreement_management',
        'end_user_license_management',
        'license_agreement_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def end_user_license_agreements_create_instance(
    body: EndUserLicenseAgreementCreateRequest,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/endUserLicenseAgreements/{id}',
    tags=['app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def end_user_license_agreements_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/endUserLicenseAgreements/{id}',
    tags=[
        'user_license_agreement_management',
        'end_user_license_management',
        'license_agreement_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def end_user_license_agreements_get_instance(
    fields_end_user_license_agreements_: Optional[
        FieldsEndUserLicenseAgreements3
    ] = Query(None, alias='fields[endUserLicenseAgreements]'),
    include: Optional[Include55] = None,
    fields_territories_: Optional[FieldsTerritories6] = Query(
        None, alias='fields[territories]'
    ),
    limit_territories_: Optional[conint(le=50)] = Query(
        None, alias='limit[territories]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/endUserLicenseAgreements/{id}',
    tags=[
        'user_license_agreement_management',
        'end_user_license_management',
        'license_agreement_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def end_user_license_agreements_update_instance(
    id: str, body: EndUserLicenseAgreementUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/endUserLicenseAgreements/{id}/territories',
    tags=['app_info_management', 'app_information_retrieval', 'territory_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def end_user_license_agreements_territories_get_to_many_related(
    fields_territories_: Optional[FieldsTerritories7] = Query(
        None, alias='fields[territories]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/financeReports',
    tags=['app_listing_management', 'finance_reporting', 'sales_reporting'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def finance_reports_get_collection(
    filter_region_code_: FilterRegionCode = Query(..., alias='filter[regionCode]'),
    filter_report_date_: FilterReportDate = Query(..., alias='filter[reportDate]'),
    filter_report_type_: FilterReportType = Query(..., alias='filter[reportType]'),
    filter_vendor_number_: FilterVendorNumber = Query(
        ..., alias='filter[vendorNumber]'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/gameCenterEnabledVersions/{id}/compatibleVersions',
    tags=[
        'app_listing_management',
        'app_information_retrieval',
        'app_store_interaction_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_compatible_game_center_versions(
    filter_platform_: Optional[FilterPlatform9] = Query(None, alias='filter[platform]'),
    filter_version_string_: Optional[FilterVersionString] = Query(
        None, alias='filter[versionString]'
    ),
    filter_app_: Optional[FilterApp] = Query(None, alias='filter[app]'),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort9] = None,
    fields_game_center_enabled_versions_: Optional[
        FieldsGameCenterEnabledVersions3
    ] = Query(None, alias='fields[gameCenterEnabledVersions]'),
    fields_apps_: Optional[FieldsApps31] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include56] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions',
    tags=['game_center_version_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_compatible_versions_linkages(
    id: str, body: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_compatible_versions_with_limit(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions',
    tags=['game_center_version_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_game_center_compatible_versions_relationship(
    id: str, body: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/gameCenterEnabledVersions/{id}/relationships/compatibleVersions',
    tags=['game_center_version_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_game_center_compatible_version_relationship(
    id: str, body: GameCenterEnabledVersionCompatibleVersionsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/idfaDeclarations',
    tags=['idfa_declaration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def idfa_declarations_create_instance(body: IdfaDeclarationCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/idfaDeclarations/{id}',
    tags=['app_information_retrieval', 'app_info_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def idfa_declarations_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/idfaDeclarations/{id}',
    tags=['app_encryption_management', 'idfa_declaration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def idfa_declarations_update_instance(
    id: str, body: IdfaDeclarationUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/inAppPurchases/{id}',
    tags=[
        'in_app_purchase_management',
        'app_store_interaction_management',
        'app_information_retrieval',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def in_app_purchases_get_instance(
    fields_in_app_purchases_: Optional[FieldsInAppPurchases3] = Query(
        None, alias='fields[inAppPurchases]'
    ),
    include: Optional[Include57] = None,
    limit_apps_: Optional[conint(le=50)] = Query(None, alias='limit[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/preReleaseVersions',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'build_related_entities_management',
        'build_performance_metrics_management',
        'pre_release_version_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def pre_release_versions_get_collection(
    filter_builds_expired_: Optional[FilterBuildsExpired] = Query(
        None, alias='filter[builds.expired]'
    ),
    filter_builds_processing_state_: Optional[FilterBuildsProcessingState] = Query(
        None, alias='filter[builds.processingState]'
    ),
    filter_platform_: Optional[FilterPlatform10] = Query(
        None, alias='filter[platform]'
    ),
    filter_version_: Optional[FilterVersion] = Query(None, alias='filter[version]'),
    filter_app_: Optional[FilterApp] = Query(None, alias='filter[app]'),
    filter_builds_: Optional[FilterBuilds] = Query(None, alias='filter[builds]'),
    sort: Optional[Sort10] = None,
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions6] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include58] = None,
    fields_builds_: Optional[FieldsBuilds23] = Query(None, alias='fields[builds]'),
    fields_apps_: Optional[FieldsApps32] = Query(None, alias='fields[apps]'),
    limit_builds_: Optional[conint(le=50)] = Query(None, alias='limit[builds]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/preReleaseVersions/{id}',
    tags=[
        'pre_release_version_management',
        'build_relationships_management',
        'build_detail_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def pre_release_versions_get_instance(
    fields_pre_release_versions_: Optional[FieldsPreReleaseVersions7] = Query(
        None, alias='fields[preReleaseVersions]'
    ),
    include: Optional[Include59] = None,
    fields_builds_: Optional[FieldsBuilds24] = Query(None, alias='fields[builds]'),
    fields_apps_: Optional[FieldsApps33] = Query(None, alias='fields[apps]'),
    limit_builds_: Optional[conint(le=50)] = Query(None, alias='limit[builds]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/preReleaseVersions/{id}/app',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def pre_release_versions_app_get_to_one_related(
    fields_apps_: Optional[FieldsApps34] = Query(None, alias='fields[apps]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/preReleaseVersions/{id}/builds',
    tags=[
        'build_relationships_management',
        'build_detail_management',
        'build_collection_management',
        'build_related_entities_management',
        'build_performance_metrics_management',
        'pre_release_version_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def pre_release_versions_builds_get_to_many_related(
    fields_builds_: Optional[FieldsBuilds25] = Query(None, alias='fields[builds]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/profiles',
    tags=[
        'app_listing_management',
        'app_information_retrieval',
        'user_profile_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def profiles_get_collection(
    filter_name_: Optional[FilterName] = Query(None, alias='filter[name]'),
    filter_profile_state_: Optional[FilterProfileState] = Query(
        None, alias='filter[profileState]'
    ),
    filter_profile_type_: Optional[FilterProfileType] = Query(
        None, alias='filter[profileType]'
    ),
    filter_id_: Optional[FilterId] = Query(None, alias='filter[id]'),
    sort: Optional[Sort11] = None,
    fields_profiles_: Optional[FieldsProfiles3] = Query(None, alias='fields[profiles]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include60] = None,
    fields_certificates_: Optional[FieldsCertificates2] = Query(
        None, alias='fields[certificates]'
    ),
    fields_devices_: Optional[FieldsDevices2] = Query(None, alias='fields[devices]'),
    fields_bundle_ids_: Optional[FieldsBundleIds2] = Query(
        None, alias='fields[bundleIds]'
    ),
    limit_certificates_: Optional[conint(le=50)] = Query(
        None, alias='limit[certificates]'
    ),
    limit_devices_: Optional[conint(le=50)] = Query(None, alias='limit[devices]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/profiles',
    tags=['user_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def profiles_create_instance(body: ProfileCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/profiles/{id}',
    tags=['app_information_retrieval', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def profiles_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/profiles/{id}',
    tags=[
        'app_information_retrieval',
        'app_info_management',
        'certificate_management',
        'device_management',
        'bundle_id_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def profiles_get_instance(
    fields_profiles_: Optional[FieldsProfiles4] = Query(None, alias='fields[profiles]'),
    include: Optional[Include61] = None,
    fields_certificates_: Optional[FieldsCertificates3] = Query(
        None, alias='fields[certificates]'
    ),
    fields_devices_: Optional[FieldsDevices3] = Query(None, alias='fields[devices]'),
    fields_bundle_ids_: Optional[FieldsBundleIds3] = Query(
        None, alias='fields[bundleIds]'
    ),
    limit_certificates_: Optional[conint(le=50)] = Query(
        None, alias='limit[certificates]'
    ),
    limit_devices_: Optional[conint(le=50)] = Query(None, alias='limit[devices]'),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/profiles/{id}/bundleId',
    tags=['bundle_id_management', 'app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def profiles_bundle_id_get_to_one_related(
    fields_bundle_ids_: Optional[FieldsBundleIds4] = Query(
        None, alias='fields[bundleIds]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/profiles/{id}/certificates',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def profiles_certificates_get_to_many_related(
    fields_certificates_: Optional[FieldsCertificates4] = Query(
        None, alias='fields[certificates]'
    ),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/profiles/{id}/devices',
    tags=['device_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def profiles_devices_get_to_many_related(
    fields_devices_: Optional[FieldsDevices4] = Query(None, alias='fields[devices]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/routingAppCoverages',
    tags=['routing_app_coverage_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def routing_app_coverages_create_instance(body: RoutingAppCoverageCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/routingAppCoverages/{id}',
    tags=['app_information_retrieval', 'app_listing_management', 'user_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def routing_app_coverages_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/routingAppCoverages/{id}',
    tags=['routing_app_coverage_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def routing_app_coverages_get_instance(
    fields_routing_app_coverages_: Optional[FieldsRoutingAppCoverages3] = Query(
        None, alias='fields[routingAppCoverages]'
    ),
    include: Optional[Include62] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/routingAppCoverages/{id}',
    tags=['routing_app_coverage_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def routing_app_coverages_update_instance(
    id: str, body: RoutingAppCoverageUpdateRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/salesReports',
    tags=['app_listing_management', 'app_information_retrieval', 'sales_reporting'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def sales_reports_get_collection(
    filter_frequency_: FilterFrequency = Query(..., alias='filter[frequency]'),
    filter_report_date_: Optional[FilterReportDate] = Query(
        None, alias='filter[reportDate]'
    ),
    filter_report_sub_type_: FilterReportSubType = Query(
        ..., alias='filter[reportSubType]'
    ),
    filter_report_type_: FilterReportType1 = Query(..., alias='filter[reportType]'),
    filter_vendor_number_: FilterVendorNumber = Query(
        ..., alias='filter[vendorNumber]'
    ),
    filter_version_: Optional[FilterVersion] = Query(None, alias='filter[version]'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/territories',
    tags=['territory_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def territories_get_collection(
    fields_territories_: Optional[FieldsTerritories8] = Query(
        None, alias='fields[territories]'
    ),
    limit: Optional[conint(le=200)] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/userInvitations',
    tags=['user_invitation_management', 'user_invitations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def user_invitations_get_collection(
    filter_email_: Optional[FilterEmail] = Query(None, alias='filter[email]'),
    filter_roles_: Optional[FilterRoles] = Query(None, alias='filter[roles]'),
    filter_visible_apps_: Optional[FilterVisibleApps] = Query(
        None, alias='filter[visibleApps]'
    ),
    sort: Optional[Sort12] = None,
    fields_user_invitations_: Optional[FieldsUserInvitations] = Query(
        None, alias='fields[userInvitations]'
    ),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include63] = None,
    fields_apps_: Optional[FieldsApps35] = Query(None, alias='fields[apps]'),
    limit_visible_apps_: Optional[conint(le=50)] = Query(
        None, alias='limit[visibleApps]'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/userInvitations',
    tags=['user_invitation_management', 'user_invitations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def user_invitations_create_instance(body: UserInvitationCreateRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/userInvitations/{id}',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def user_invitations_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/userInvitations/{id}',
    tags=[
        'user_invitation_management',
        'user_invitations_management',
        'user_visible_apps_relationships_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def user_invitations_get_instance(
    fields_user_invitations_: Optional[FieldsUserInvitations1] = Query(
        None, alias='fields[userInvitations]'
    ),
    include: Optional[Include64] = None,
    fields_apps_: Optional[FieldsApps36] = Query(None, alias='fields[apps]'),
    limit_visible_apps_: Optional[conint(le=50)] = Query(
        None, alias='limit[visibleApps]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/userInvitations/{id}/visibleApps',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def user_invitations_visible_apps_get_to_many_related(
    fields_apps_: Optional[FieldsApps37] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/users',
    tags=[
        'user_management',
        'user_visible_apps_relationships_management',
        'user_invitations_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_get_collection(
    filter_roles_: Optional[FilterRoles1] = Query(None, alias='filter[roles]'),
    filter_username_: Optional[FilterUsername] = Query(None, alias='filter[username]'),
    filter_visible_apps_: Optional[FilterVisibleApps] = Query(
        None, alias='filter[visibleApps]'
    ),
    sort: Optional[Sort13] = None,
    fields_users_: Optional[FieldsUsers] = Query(None, alias='fields[users]'),
    limit: Optional[conint(le=200)] = None,
    include: Optional[Include65] = None,
    fields_apps_: Optional[FieldsApps38] = Query(None, alias='fields[apps]'),
    limit_visible_apps_: Optional[conint(le=50)] = Query(
        None, alias='limit[visibleApps]'
    ),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/users/{id}',
    tags=['app_information_retrieval', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_delete_instance(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/users/{id}',
    tags=['user_visible_apps_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_get_instance(
    fields_users_: Optional[FieldsUsers1] = Query(None, alias='fields[users]'),
    include: Optional[Include66] = None,
    fields_apps_: Optional[FieldsApps39] = Query(None, alias='fields[apps]'),
    limit_visible_apps_: Optional[conint(le=50)] = Query(
        None, alias='limit[visibleApps]'
    ),
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/users/{id}',
    tags=['user_management', 'user_profile_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_update_instance(id: str, body: UserUpdateRequest = ...):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/users/{id}/relationships/visibleApps',
    tags=['user_visible_apps_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_visible_apps_delete_to_many_relationship(
    id: str, body: UserVisibleAppsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/users/{id}/relationships/visibleApps',
    tags=['app_info_management', 'app_information_retrieval'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_visible_apps_get_to_many_relationship(
    limit: Optional[conint(le=200)] = None, id: str = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/v1/users/{id}/relationships/visibleApps',
    tags=['user_visible_apps_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_visible_apps_replace_to_many_relationship(
    id: str, body: UserVisibleAppsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/users/{id}/relationships/visibleApps',
    tags=['user_visible_apps_relationships_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_visible_apps_create_to_many_relationship(
    id: str, body: UserVisibleAppsLinkagesRequest = ...
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/users/{id}/visibleApps',
    tags=['app_information_retrieval', 'app_info_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def users_visible_apps_get_to_many_related(
    fields_apps_: Optional[FieldsApps40] = Query(None, alias='fields[apps]'),
    limit: Optional[conint(le=200)] = None,
    id: str = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
